// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: studio.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_studio_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_studio_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "meta.pb.h"
#include "core.pb.h"
#include "behaviors.pb.h"
#include "keymap.pb.h"
#include "led_settings.pb.h"
#include "analog_keymap.pb.h"
#include "testing.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_studio_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_studio_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_studio_2eproto;
namespace zmk {
namespace studio {
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestResponse;
struct RequestResponseDefaultTypeInternal;
extern RequestResponseDefaultTypeInternal _RequestResponse_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
}  // namespace studio
}  // namespace zmk
PROTOBUF_NAMESPACE_OPEN
template<> ::zmk::studio::Notification* Arena::CreateMaybeMessage<::zmk::studio::Notification>(Arena*);
template<> ::zmk::studio::Request* Arena::CreateMaybeMessage<::zmk::studio::Request>(Arena*);
template<> ::zmk::studio::RequestResponse* Arena::CreateMaybeMessage<::zmk::studio::RequestResponse>(Arena*);
template<> ::zmk::studio::Response* Arena::CreateMaybeMessage<::zmk::studio::Response>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zmk {
namespace studio {

// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.studio.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum SubsystemCase {
    kCore = 3,
    kBehaviors = 4,
    kKeymap = 5,
    kLedSettings = 64,
    kAnalogKeymap = 65,
    kTesting = 66,
    SUBSYSTEM_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.studio.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kCoreFieldNumber = 3,
    kBehaviorsFieldNumber = 4,
    kKeymapFieldNumber = 5,
    kLedSettingsFieldNumber = 64,
    kAnalogKeymapFieldNumber = 65,
    kTestingFieldNumber = 66,
  };
  // uint32 request_id = 1;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // .zmk.core.Request core = 3;
  bool has_core() const;
  private:
  bool _internal_has_core() const;
  public:
  void clear_core();
  const ::zmk::core::Request& core() const;
  PROTOBUF_NODISCARD ::zmk::core::Request* release_core();
  ::zmk::core::Request* mutable_core();
  void set_allocated_core(::zmk::core::Request* core);
  private:
  const ::zmk::core::Request& _internal_core() const;
  ::zmk::core::Request* _internal_mutable_core();
  public:
  void unsafe_arena_set_allocated_core(
      ::zmk::core::Request* core);
  ::zmk::core::Request* unsafe_arena_release_core();

  // .zmk.behaviors.Request behaviors = 4;
  bool has_behaviors() const;
  private:
  bool _internal_has_behaviors() const;
  public:
  void clear_behaviors();
  const ::zmk::behaviors::Request& behaviors() const;
  PROTOBUF_NODISCARD ::zmk::behaviors::Request* release_behaviors();
  ::zmk::behaviors::Request* mutable_behaviors();
  void set_allocated_behaviors(::zmk::behaviors::Request* behaviors);
  private:
  const ::zmk::behaviors::Request& _internal_behaviors() const;
  ::zmk::behaviors::Request* _internal_mutable_behaviors();
  public:
  void unsafe_arena_set_allocated_behaviors(
      ::zmk::behaviors::Request* behaviors);
  ::zmk::behaviors::Request* unsafe_arena_release_behaviors();

  // .zmk.keymap.Request keymap = 5;
  bool has_keymap() const;
  private:
  bool _internal_has_keymap() const;
  public:
  void clear_keymap();
  const ::zmk::keymap::Request& keymap() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Request* release_keymap();
  ::zmk::keymap::Request* mutable_keymap();
  void set_allocated_keymap(::zmk::keymap::Request* keymap);
  private:
  const ::zmk::keymap::Request& _internal_keymap() const;
  ::zmk::keymap::Request* _internal_mutable_keymap();
  public:
  void unsafe_arena_set_allocated_keymap(
      ::zmk::keymap::Request* keymap);
  ::zmk::keymap::Request* unsafe_arena_release_keymap();

  // .zmk.led_settings.Request led_settings = 64;
  bool has_led_settings() const;
  private:
  bool _internal_has_led_settings() const;
  public:
  void clear_led_settings();
  const ::zmk::led_settings::Request& led_settings() const;
  PROTOBUF_NODISCARD ::zmk::led_settings::Request* release_led_settings();
  ::zmk::led_settings::Request* mutable_led_settings();
  void set_allocated_led_settings(::zmk::led_settings::Request* led_settings);
  private:
  const ::zmk::led_settings::Request& _internal_led_settings() const;
  ::zmk::led_settings::Request* _internal_mutable_led_settings();
  public:
  void unsafe_arena_set_allocated_led_settings(
      ::zmk::led_settings::Request* led_settings);
  ::zmk::led_settings::Request* unsafe_arena_release_led_settings();

  // .zmk.analog_keymap.Request analog_keymap = 65;
  bool has_analog_keymap() const;
  private:
  bool _internal_has_analog_keymap() const;
  public:
  void clear_analog_keymap();
  const ::zmk::analog_keymap::Request& analog_keymap() const;
  PROTOBUF_NODISCARD ::zmk::analog_keymap::Request* release_analog_keymap();
  ::zmk::analog_keymap::Request* mutable_analog_keymap();
  void set_allocated_analog_keymap(::zmk::analog_keymap::Request* analog_keymap);
  private:
  const ::zmk::analog_keymap::Request& _internal_analog_keymap() const;
  ::zmk::analog_keymap::Request* _internal_mutable_analog_keymap();
  public:
  void unsafe_arena_set_allocated_analog_keymap(
      ::zmk::analog_keymap::Request* analog_keymap);
  ::zmk::analog_keymap::Request* unsafe_arena_release_analog_keymap();

  // .zmk.testing.Request testing = 66;
  bool has_testing() const;
  private:
  bool _internal_has_testing() const;
  public:
  void clear_testing();
  const ::zmk::testing::Request& testing() const;
  PROTOBUF_NODISCARD ::zmk::testing::Request* release_testing();
  ::zmk::testing::Request* mutable_testing();
  void set_allocated_testing(::zmk::testing::Request* testing);
  private:
  const ::zmk::testing::Request& _internal_testing() const;
  ::zmk::testing::Request* _internal_mutable_testing();
  public:
  void unsafe_arena_set_allocated_testing(
      ::zmk::testing::Request* testing);
  ::zmk::testing::Request* unsafe_arena_release_testing();

  void clear_subsystem();
  SubsystemCase subsystem_case() const;
  // @@protoc_insertion_point(class_scope:zmk.studio.Request)
 private:
  class _Internal;
  void set_has_core();
  void set_has_behaviors();
  void set_has_keymap();
  void set_has_led_settings();
  void set_has_analog_keymap();
  void set_has_testing();

  inline bool has_subsystem() const;
  inline void clear_has_subsystem();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t request_id_;
    union SubsystemUnion {
      constexpr SubsystemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::core::Request* core_;
      ::zmk::behaviors::Request* behaviors_;
      ::zmk::keymap::Request* keymap_;
      ::zmk::led_settings::Request* led_settings_;
      ::zmk::analog_keymap::Request* analog_keymap_;
      ::zmk::testing::Request* testing_;
    } subsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_studio_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.studio.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kRequestResponse = 1,
    kNotification = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.studio.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestResponseFieldNumber = 1,
    kNotificationFieldNumber = 2,
  };
  // .zmk.studio.RequestResponse request_response = 1;
  bool has_request_response() const;
  private:
  bool _internal_has_request_response() const;
  public:
  void clear_request_response();
  const ::zmk::studio::RequestResponse& request_response() const;
  PROTOBUF_NODISCARD ::zmk::studio::RequestResponse* release_request_response();
  ::zmk::studio::RequestResponse* mutable_request_response();
  void set_allocated_request_response(::zmk::studio::RequestResponse* request_response);
  private:
  const ::zmk::studio::RequestResponse& _internal_request_response() const;
  ::zmk::studio::RequestResponse* _internal_mutable_request_response();
  public:
  void unsafe_arena_set_allocated_request_response(
      ::zmk::studio::RequestResponse* request_response);
  ::zmk::studio::RequestResponse* unsafe_arena_release_request_response();

  // .zmk.studio.Notification notification = 2;
  bool has_notification() const;
  private:
  bool _internal_has_notification() const;
  public:
  void clear_notification();
  const ::zmk::studio::Notification& notification() const;
  PROTOBUF_NODISCARD ::zmk::studio::Notification* release_notification();
  ::zmk::studio::Notification* mutable_notification();
  void set_allocated_notification(::zmk::studio::Notification* notification);
  private:
  const ::zmk::studio::Notification& _internal_notification() const;
  ::zmk::studio::Notification* _internal_mutable_notification();
  public:
  void unsafe_arena_set_allocated_notification(
      ::zmk::studio::Notification* notification);
  ::zmk::studio::Notification* unsafe_arena_release_notification();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:zmk.studio.Response)
 private:
  class _Internal;
  void set_has_request_response();
  void set_has_notification();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::studio::RequestResponse* request_response_;
      ::zmk::studio::Notification* notification_;
    } type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_studio_2eproto;
};
// -------------------------------------------------------------------

class RequestResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.studio.RequestResponse) */ {
 public:
  inline RequestResponse() : RequestResponse(nullptr) {}
  ~RequestResponse() override;
  explicit PROTOBUF_CONSTEXPR RequestResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestResponse(const RequestResponse& from);
  RequestResponse(RequestResponse&& from) noexcept
    : RequestResponse() {
    *this = ::std::move(from);
  }

  inline RequestResponse& operator=(const RequestResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestResponse& operator=(RequestResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestResponse& default_instance() {
    return *internal_default_instance();
  }
  enum SubsystemCase {
    kMeta = 2,
    kCore = 3,
    kBehaviors = 4,
    kKeymap = 5,
    kLedSettings = 64,
    kAnalogKeymap = 65,
    kTesting = 66,
    SUBSYSTEM_NOT_SET = 0,
  };

  static inline const RequestResponse* internal_default_instance() {
    return reinterpret_cast<const RequestResponse*>(
               &_RequestResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RequestResponse& a, RequestResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestResponse& from) {
    RequestResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.studio.RequestResponse";
  }
  protected:
  explicit RequestResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kMetaFieldNumber = 2,
    kCoreFieldNumber = 3,
    kBehaviorsFieldNumber = 4,
    kKeymapFieldNumber = 5,
    kLedSettingsFieldNumber = 64,
    kAnalogKeymapFieldNumber = 65,
    kTestingFieldNumber = 66,
  };
  // uint32 request_id = 1;
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // .zmk.meta.Response meta = 2;
  bool has_meta() const;
  private:
  bool _internal_has_meta() const;
  public:
  void clear_meta();
  const ::zmk::meta::Response& meta() const;
  PROTOBUF_NODISCARD ::zmk::meta::Response* release_meta();
  ::zmk::meta::Response* mutable_meta();
  void set_allocated_meta(::zmk::meta::Response* meta);
  private:
  const ::zmk::meta::Response& _internal_meta() const;
  ::zmk::meta::Response* _internal_mutable_meta();
  public:
  void unsafe_arena_set_allocated_meta(
      ::zmk::meta::Response* meta);
  ::zmk::meta::Response* unsafe_arena_release_meta();

  // .zmk.core.Response core = 3;
  bool has_core() const;
  private:
  bool _internal_has_core() const;
  public:
  void clear_core();
  const ::zmk::core::Response& core() const;
  PROTOBUF_NODISCARD ::zmk::core::Response* release_core();
  ::zmk::core::Response* mutable_core();
  void set_allocated_core(::zmk::core::Response* core);
  private:
  const ::zmk::core::Response& _internal_core() const;
  ::zmk::core::Response* _internal_mutable_core();
  public:
  void unsafe_arena_set_allocated_core(
      ::zmk::core::Response* core);
  ::zmk::core::Response* unsafe_arena_release_core();

  // .zmk.behaviors.Response behaviors = 4;
  bool has_behaviors() const;
  private:
  bool _internal_has_behaviors() const;
  public:
  void clear_behaviors();
  const ::zmk::behaviors::Response& behaviors() const;
  PROTOBUF_NODISCARD ::zmk::behaviors::Response* release_behaviors();
  ::zmk::behaviors::Response* mutable_behaviors();
  void set_allocated_behaviors(::zmk::behaviors::Response* behaviors);
  private:
  const ::zmk::behaviors::Response& _internal_behaviors() const;
  ::zmk::behaviors::Response* _internal_mutable_behaviors();
  public:
  void unsafe_arena_set_allocated_behaviors(
      ::zmk::behaviors::Response* behaviors);
  ::zmk::behaviors::Response* unsafe_arena_release_behaviors();

  // .zmk.keymap.Response keymap = 5;
  bool has_keymap() const;
  private:
  bool _internal_has_keymap() const;
  public:
  void clear_keymap();
  const ::zmk::keymap::Response& keymap() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Response* release_keymap();
  ::zmk::keymap::Response* mutable_keymap();
  void set_allocated_keymap(::zmk::keymap::Response* keymap);
  private:
  const ::zmk::keymap::Response& _internal_keymap() const;
  ::zmk::keymap::Response* _internal_mutable_keymap();
  public:
  void unsafe_arena_set_allocated_keymap(
      ::zmk::keymap::Response* keymap);
  ::zmk::keymap::Response* unsafe_arena_release_keymap();

  // .zmk.led_settings.Response led_settings = 64;
  bool has_led_settings() const;
  private:
  bool _internal_has_led_settings() const;
  public:
  void clear_led_settings();
  const ::zmk::led_settings::Response& led_settings() const;
  PROTOBUF_NODISCARD ::zmk::led_settings::Response* release_led_settings();
  ::zmk::led_settings::Response* mutable_led_settings();
  void set_allocated_led_settings(::zmk::led_settings::Response* led_settings);
  private:
  const ::zmk::led_settings::Response& _internal_led_settings() const;
  ::zmk::led_settings::Response* _internal_mutable_led_settings();
  public:
  void unsafe_arena_set_allocated_led_settings(
      ::zmk::led_settings::Response* led_settings);
  ::zmk::led_settings::Response* unsafe_arena_release_led_settings();

  // .zmk.analog_keymap.Response analog_keymap = 65;
  bool has_analog_keymap() const;
  private:
  bool _internal_has_analog_keymap() const;
  public:
  void clear_analog_keymap();
  const ::zmk::analog_keymap::Response& analog_keymap() const;
  PROTOBUF_NODISCARD ::zmk::analog_keymap::Response* release_analog_keymap();
  ::zmk::analog_keymap::Response* mutable_analog_keymap();
  void set_allocated_analog_keymap(::zmk::analog_keymap::Response* analog_keymap);
  private:
  const ::zmk::analog_keymap::Response& _internal_analog_keymap() const;
  ::zmk::analog_keymap::Response* _internal_mutable_analog_keymap();
  public:
  void unsafe_arena_set_allocated_analog_keymap(
      ::zmk::analog_keymap::Response* analog_keymap);
  ::zmk::analog_keymap::Response* unsafe_arena_release_analog_keymap();

  // .zmk.testing.Response testing = 66;
  bool has_testing() const;
  private:
  bool _internal_has_testing() const;
  public:
  void clear_testing();
  const ::zmk::testing::Response& testing() const;
  PROTOBUF_NODISCARD ::zmk::testing::Response* release_testing();
  ::zmk::testing::Response* mutable_testing();
  void set_allocated_testing(::zmk::testing::Response* testing);
  private:
  const ::zmk::testing::Response& _internal_testing() const;
  ::zmk::testing::Response* _internal_mutable_testing();
  public:
  void unsafe_arena_set_allocated_testing(
      ::zmk::testing::Response* testing);
  ::zmk::testing::Response* unsafe_arena_release_testing();

  void clear_subsystem();
  SubsystemCase subsystem_case() const;
  // @@protoc_insertion_point(class_scope:zmk.studio.RequestResponse)
 private:
  class _Internal;
  void set_has_meta();
  void set_has_core();
  void set_has_behaviors();
  void set_has_keymap();
  void set_has_led_settings();
  void set_has_analog_keymap();
  void set_has_testing();

  inline bool has_subsystem() const;
  inline void clear_has_subsystem();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t request_id_;
    union SubsystemUnion {
      constexpr SubsystemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::meta::Response* meta_;
      ::zmk::core::Response* core_;
      ::zmk::behaviors::Response* behaviors_;
      ::zmk::keymap::Response* keymap_;
      ::zmk::led_settings::Response* led_settings_;
      ::zmk::analog_keymap::Response* analog_keymap_;
      ::zmk::testing::Response* testing_;
    } subsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_studio_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.studio.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  enum SubsystemCase {
    kCore = 2,
    kKeymap = 5,
    SUBSYSTEM_NOT_SET = 0,
  };

  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.studio.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCoreFieldNumber = 2,
    kKeymapFieldNumber = 5,
  };
  // .zmk.core.Notification core = 2;
  bool has_core() const;
  private:
  bool _internal_has_core() const;
  public:
  void clear_core();
  const ::zmk::core::Notification& core() const;
  PROTOBUF_NODISCARD ::zmk::core::Notification* release_core();
  ::zmk::core::Notification* mutable_core();
  void set_allocated_core(::zmk::core::Notification* core);
  private:
  const ::zmk::core::Notification& _internal_core() const;
  ::zmk::core::Notification* _internal_mutable_core();
  public:
  void unsafe_arena_set_allocated_core(
      ::zmk::core::Notification* core);
  ::zmk::core::Notification* unsafe_arena_release_core();

  // .zmk.keymap.Notification keymap = 5;
  bool has_keymap() const;
  private:
  bool _internal_has_keymap() const;
  public:
  void clear_keymap();
  const ::zmk::keymap::Notification& keymap() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Notification* release_keymap();
  ::zmk::keymap::Notification* mutable_keymap();
  void set_allocated_keymap(::zmk::keymap::Notification* keymap);
  private:
  const ::zmk::keymap::Notification& _internal_keymap() const;
  ::zmk::keymap::Notification* _internal_mutable_keymap();
  public:
  void unsafe_arena_set_allocated_keymap(
      ::zmk::keymap::Notification* keymap);
  ::zmk::keymap::Notification* unsafe_arena_release_keymap();

  void clear_subsystem();
  SubsystemCase subsystem_case() const;
  // @@protoc_insertion_point(class_scope:zmk.studio.Notification)
 private:
  class _Internal;
  void set_has_core();
  void set_has_keymap();

  inline bool has_subsystem() const;
  inline void clear_has_subsystem();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union SubsystemUnion {
      constexpr SubsystemUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::core::Notification* core_;
      ::zmk::keymap::Notification* keymap_;
    } subsystem_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_studio_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// uint32 request_id = 1;
inline void Request::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t Request::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t Request::request_id() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.request_id)
  return _internal_request_id();
}
inline void Request::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void Request::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:zmk.studio.Request.request_id)
}

// .zmk.core.Request core = 3;
inline bool Request::_internal_has_core() const {
  return subsystem_case() == kCore;
}
inline bool Request::has_core() const {
  return _internal_has_core();
}
inline void Request::set_has_core() {
  _impl_._oneof_case_[0] = kCore;
}
inline ::zmk::core::Request* Request::release_core() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Request* temp = _impl_.subsystem_.core_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::core::Request& Request::_internal_core() const {
  return _internal_has_core()
      ? *_impl_.subsystem_.core_
      : reinterpret_cast< ::zmk::core::Request&>(::zmk::core::_Request_default_instance_);
}
inline const ::zmk::core::Request& Request::core() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.core)
  return _internal_core();
}
inline ::zmk::core::Request* Request::unsafe_arena_release_core() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Request* temp = _impl_.subsystem_.core_;
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_core(::zmk::core::Request* core) {
  clear_subsystem();
  if (core) {
    set_has_core();
    _impl_.subsystem_.core_ = core;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.core)
}
inline ::zmk::core::Request* Request::_internal_mutable_core() {
  if (!_internal_has_core()) {
    clear_subsystem();
    set_has_core();
    _impl_.subsystem_.core_ = CreateMaybeMessage< ::zmk::core::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.core_;
}
inline ::zmk::core::Request* Request::mutable_core() {
  ::zmk::core::Request* _msg = _internal_mutable_core();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.core)
  return _msg;
}

// .zmk.behaviors.Request behaviors = 4;
inline bool Request::_internal_has_behaviors() const {
  return subsystem_case() == kBehaviors;
}
inline bool Request::has_behaviors() const {
  return _internal_has_behaviors();
}
inline void Request::set_has_behaviors() {
  _impl_._oneof_case_[0] = kBehaviors;
}
inline ::zmk::behaviors::Request* Request::release_behaviors() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.behaviors)
  if (_internal_has_behaviors()) {
    clear_has_subsystem();
    ::zmk::behaviors::Request* temp = _impl_.subsystem_.behaviors_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.behaviors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::behaviors::Request& Request::_internal_behaviors() const {
  return _internal_has_behaviors()
      ? *_impl_.subsystem_.behaviors_
      : reinterpret_cast< ::zmk::behaviors::Request&>(::zmk::behaviors::_Request_default_instance_);
}
inline const ::zmk::behaviors::Request& Request::behaviors() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.behaviors)
  return _internal_behaviors();
}
inline ::zmk::behaviors::Request* Request::unsafe_arena_release_behaviors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.behaviors)
  if (_internal_has_behaviors()) {
    clear_has_subsystem();
    ::zmk::behaviors::Request* temp = _impl_.subsystem_.behaviors_;
    _impl_.subsystem_.behaviors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_behaviors(::zmk::behaviors::Request* behaviors) {
  clear_subsystem();
  if (behaviors) {
    set_has_behaviors();
    _impl_.subsystem_.behaviors_ = behaviors;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.behaviors)
}
inline ::zmk::behaviors::Request* Request::_internal_mutable_behaviors() {
  if (!_internal_has_behaviors()) {
    clear_subsystem();
    set_has_behaviors();
    _impl_.subsystem_.behaviors_ = CreateMaybeMessage< ::zmk::behaviors::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.behaviors_;
}
inline ::zmk::behaviors::Request* Request::mutable_behaviors() {
  ::zmk::behaviors::Request* _msg = _internal_mutable_behaviors();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.behaviors)
  return _msg;
}

// .zmk.keymap.Request keymap = 5;
inline bool Request::_internal_has_keymap() const {
  return subsystem_case() == kKeymap;
}
inline bool Request::has_keymap() const {
  return _internal_has_keymap();
}
inline void Request::set_has_keymap() {
  _impl_._oneof_case_[0] = kKeymap;
}
inline ::zmk::keymap::Request* Request::release_keymap() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Request* temp = _impl_.subsystem_.keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Request& Request::_internal_keymap() const {
  return _internal_has_keymap()
      ? *_impl_.subsystem_.keymap_
      : reinterpret_cast< ::zmk::keymap::Request&>(::zmk::keymap::_Request_default_instance_);
}
inline const ::zmk::keymap::Request& Request::keymap() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.keymap)
  return _internal_keymap();
}
inline ::zmk::keymap::Request* Request::unsafe_arena_release_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Request* temp = _impl_.subsystem_.keymap_;
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_keymap(::zmk::keymap::Request* keymap) {
  clear_subsystem();
  if (keymap) {
    set_has_keymap();
    _impl_.subsystem_.keymap_ = keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.keymap)
}
inline ::zmk::keymap::Request* Request::_internal_mutable_keymap() {
  if (!_internal_has_keymap()) {
    clear_subsystem();
    set_has_keymap();
    _impl_.subsystem_.keymap_ = CreateMaybeMessage< ::zmk::keymap::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.keymap_;
}
inline ::zmk::keymap::Request* Request::mutable_keymap() {
  ::zmk::keymap::Request* _msg = _internal_mutable_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.keymap)
  return _msg;
}

// .zmk.led_settings.Request led_settings = 64;
inline bool Request::_internal_has_led_settings() const {
  return subsystem_case() == kLedSettings;
}
inline bool Request::has_led_settings() const {
  return _internal_has_led_settings();
}
inline void Request::set_has_led_settings() {
  _impl_._oneof_case_[0] = kLedSettings;
}
inline ::zmk::led_settings::Request* Request::release_led_settings() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.led_settings)
  if (_internal_has_led_settings()) {
    clear_has_subsystem();
    ::zmk::led_settings::Request* temp = _impl_.subsystem_.led_settings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.led_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::led_settings::Request& Request::_internal_led_settings() const {
  return _internal_has_led_settings()
      ? *_impl_.subsystem_.led_settings_
      : reinterpret_cast< ::zmk::led_settings::Request&>(::zmk::led_settings::_Request_default_instance_);
}
inline const ::zmk::led_settings::Request& Request::led_settings() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.led_settings)
  return _internal_led_settings();
}
inline ::zmk::led_settings::Request* Request::unsafe_arena_release_led_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.led_settings)
  if (_internal_has_led_settings()) {
    clear_has_subsystem();
    ::zmk::led_settings::Request* temp = _impl_.subsystem_.led_settings_;
    _impl_.subsystem_.led_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_led_settings(::zmk::led_settings::Request* led_settings) {
  clear_subsystem();
  if (led_settings) {
    set_has_led_settings();
    _impl_.subsystem_.led_settings_ = led_settings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.led_settings)
}
inline ::zmk::led_settings::Request* Request::_internal_mutable_led_settings() {
  if (!_internal_has_led_settings()) {
    clear_subsystem();
    set_has_led_settings();
    _impl_.subsystem_.led_settings_ = CreateMaybeMessage< ::zmk::led_settings::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.led_settings_;
}
inline ::zmk::led_settings::Request* Request::mutable_led_settings() {
  ::zmk::led_settings::Request* _msg = _internal_mutable_led_settings();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.led_settings)
  return _msg;
}

// .zmk.analog_keymap.Request analog_keymap = 65;
inline bool Request::_internal_has_analog_keymap() const {
  return subsystem_case() == kAnalogKeymap;
}
inline bool Request::has_analog_keymap() const {
  return _internal_has_analog_keymap();
}
inline void Request::set_has_analog_keymap() {
  _impl_._oneof_case_[0] = kAnalogKeymap;
}
inline ::zmk::analog_keymap::Request* Request::release_analog_keymap() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.analog_keymap)
  if (_internal_has_analog_keymap()) {
    clear_has_subsystem();
    ::zmk::analog_keymap::Request* temp = _impl_.subsystem_.analog_keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.analog_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::analog_keymap::Request& Request::_internal_analog_keymap() const {
  return _internal_has_analog_keymap()
      ? *_impl_.subsystem_.analog_keymap_
      : reinterpret_cast< ::zmk::analog_keymap::Request&>(::zmk::analog_keymap::_Request_default_instance_);
}
inline const ::zmk::analog_keymap::Request& Request::analog_keymap() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.analog_keymap)
  return _internal_analog_keymap();
}
inline ::zmk::analog_keymap::Request* Request::unsafe_arena_release_analog_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.analog_keymap)
  if (_internal_has_analog_keymap()) {
    clear_has_subsystem();
    ::zmk::analog_keymap::Request* temp = _impl_.subsystem_.analog_keymap_;
    _impl_.subsystem_.analog_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_analog_keymap(::zmk::analog_keymap::Request* analog_keymap) {
  clear_subsystem();
  if (analog_keymap) {
    set_has_analog_keymap();
    _impl_.subsystem_.analog_keymap_ = analog_keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.analog_keymap)
}
inline ::zmk::analog_keymap::Request* Request::_internal_mutable_analog_keymap() {
  if (!_internal_has_analog_keymap()) {
    clear_subsystem();
    set_has_analog_keymap();
    _impl_.subsystem_.analog_keymap_ = CreateMaybeMessage< ::zmk::analog_keymap::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.analog_keymap_;
}
inline ::zmk::analog_keymap::Request* Request::mutable_analog_keymap() {
  ::zmk::analog_keymap::Request* _msg = _internal_mutable_analog_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.analog_keymap)
  return _msg;
}

// .zmk.testing.Request testing = 66;
inline bool Request::_internal_has_testing() const {
  return subsystem_case() == kTesting;
}
inline bool Request::has_testing() const {
  return _internal_has_testing();
}
inline void Request::set_has_testing() {
  _impl_._oneof_case_[0] = kTesting;
}
inline ::zmk::testing::Request* Request::release_testing() {
  // @@protoc_insertion_point(field_release:zmk.studio.Request.testing)
  if (_internal_has_testing()) {
    clear_has_subsystem();
    ::zmk::testing::Request* temp = _impl_.subsystem_.testing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.testing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::testing::Request& Request::_internal_testing() const {
  return _internal_has_testing()
      ? *_impl_.subsystem_.testing_
      : reinterpret_cast< ::zmk::testing::Request&>(::zmk::testing::_Request_default_instance_);
}
inline const ::zmk::testing::Request& Request::testing() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Request.testing)
  return _internal_testing();
}
inline ::zmk::testing::Request* Request::unsafe_arena_release_testing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Request.testing)
  if (_internal_has_testing()) {
    clear_has_subsystem();
    ::zmk::testing::Request* temp = _impl_.subsystem_.testing_;
    _impl_.subsystem_.testing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_testing(::zmk::testing::Request* testing) {
  clear_subsystem();
  if (testing) {
    set_has_testing();
    _impl_.subsystem_.testing_ = testing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Request.testing)
}
inline ::zmk::testing::Request* Request::_internal_mutable_testing() {
  if (!_internal_has_testing()) {
    clear_subsystem();
    set_has_testing();
    _impl_.subsystem_.testing_ = CreateMaybeMessage< ::zmk::testing::Request >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.testing_;
}
inline ::zmk::testing::Request* Request::mutable_testing() {
  ::zmk::testing::Request* _msg = _internal_mutable_testing();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Request.testing)
  return _msg;
}

inline bool Request::has_subsystem() const {
  return subsystem_case() != SUBSYSTEM_NOT_SET;
}
inline void Request::clear_has_subsystem() {
  _impl_._oneof_case_[0] = SUBSYSTEM_NOT_SET;
}
inline Request::SubsystemCase Request::subsystem_case() const {
  return Request::SubsystemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .zmk.studio.RequestResponse request_response = 1;
inline bool Response::_internal_has_request_response() const {
  return type_case() == kRequestResponse;
}
inline bool Response::has_request_response() const {
  return _internal_has_request_response();
}
inline void Response::set_has_request_response() {
  _impl_._oneof_case_[0] = kRequestResponse;
}
inline void Response::clear_request_response() {
  if (_internal_has_request_response()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.request_response_;
    }
    clear_has_type();
  }
}
inline ::zmk::studio::RequestResponse* Response::release_request_response() {
  // @@protoc_insertion_point(field_release:zmk.studio.Response.request_response)
  if (_internal_has_request_response()) {
    clear_has_type();
    ::zmk::studio::RequestResponse* temp = _impl_.type_.request_response_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::studio::RequestResponse& Response::_internal_request_response() const {
  return _internal_has_request_response()
      ? *_impl_.type_.request_response_
      : reinterpret_cast< ::zmk::studio::RequestResponse&>(::zmk::studio::_RequestResponse_default_instance_);
}
inline const ::zmk::studio::RequestResponse& Response::request_response() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Response.request_response)
  return _internal_request_response();
}
inline ::zmk::studio::RequestResponse* Response::unsafe_arena_release_request_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Response.request_response)
  if (_internal_has_request_response()) {
    clear_has_type();
    ::zmk::studio::RequestResponse* temp = _impl_.type_.request_response_;
    _impl_.type_.request_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_request_response(::zmk::studio::RequestResponse* request_response) {
  clear_type();
  if (request_response) {
    set_has_request_response();
    _impl_.type_.request_response_ = request_response;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Response.request_response)
}
inline ::zmk::studio::RequestResponse* Response::_internal_mutable_request_response() {
  if (!_internal_has_request_response()) {
    clear_type();
    set_has_request_response();
    _impl_.type_.request_response_ = CreateMaybeMessage< ::zmk::studio::RequestResponse >(GetArenaForAllocation());
  }
  return _impl_.type_.request_response_;
}
inline ::zmk::studio::RequestResponse* Response::mutable_request_response() {
  ::zmk::studio::RequestResponse* _msg = _internal_mutable_request_response();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Response.request_response)
  return _msg;
}

// .zmk.studio.Notification notification = 2;
inline bool Response::_internal_has_notification() const {
  return type_case() == kNotification;
}
inline bool Response::has_notification() const {
  return _internal_has_notification();
}
inline void Response::set_has_notification() {
  _impl_._oneof_case_[0] = kNotification;
}
inline void Response::clear_notification() {
  if (_internal_has_notification()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.type_.notification_;
    }
    clear_has_type();
  }
}
inline ::zmk::studio::Notification* Response::release_notification() {
  // @@protoc_insertion_point(field_release:zmk.studio.Response.notification)
  if (_internal_has_notification()) {
    clear_has_type();
    ::zmk::studio::Notification* temp = _impl_.type_.notification_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::studio::Notification& Response::_internal_notification() const {
  return _internal_has_notification()
      ? *_impl_.type_.notification_
      : reinterpret_cast< ::zmk::studio::Notification&>(::zmk::studio::_Notification_default_instance_);
}
inline const ::zmk::studio::Notification& Response::notification() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Response.notification)
  return _internal_notification();
}
inline ::zmk::studio::Notification* Response::unsafe_arena_release_notification() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Response.notification)
  if (_internal_has_notification()) {
    clear_has_type();
    ::zmk::studio::Notification* temp = _impl_.type_.notification_;
    _impl_.type_.notification_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_notification(::zmk::studio::Notification* notification) {
  clear_type();
  if (notification) {
    set_has_notification();
    _impl_.type_.notification_ = notification;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Response.notification)
}
inline ::zmk::studio::Notification* Response::_internal_mutable_notification() {
  if (!_internal_has_notification()) {
    clear_type();
    set_has_notification();
    _impl_.type_.notification_ = CreateMaybeMessage< ::zmk::studio::Notification >(GetArenaForAllocation());
  }
  return _impl_.type_.notification_;
}
inline ::zmk::studio::Notification* Response::mutable_notification() {
  ::zmk::studio::Notification* _msg = _internal_mutable_notification();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Response.notification)
  return _msg;
}

inline bool Response::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Response::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Response::TypeCase Response::type_case() const {
  return Response::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestResponse

// uint32 request_id = 1;
inline void RequestResponse::clear_request_id() {
  _impl_.request_id_ = 0u;
}
inline uint32_t RequestResponse::_internal_request_id() const {
  return _impl_.request_id_;
}
inline uint32_t RequestResponse::request_id() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.request_id)
  return _internal_request_id();
}
inline void RequestResponse::_internal_set_request_id(uint32_t value) {
  
  _impl_.request_id_ = value;
}
inline void RequestResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:zmk.studio.RequestResponse.request_id)
}

// .zmk.meta.Response meta = 2;
inline bool RequestResponse::_internal_has_meta() const {
  return subsystem_case() == kMeta;
}
inline bool RequestResponse::has_meta() const {
  return _internal_has_meta();
}
inline void RequestResponse::set_has_meta() {
  _impl_._oneof_case_[0] = kMeta;
}
inline ::zmk::meta::Response* RequestResponse::release_meta() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.meta)
  if (_internal_has_meta()) {
    clear_has_subsystem();
    ::zmk::meta::Response* temp = _impl_.subsystem_.meta_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::meta::Response& RequestResponse::_internal_meta() const {
  return _internal_has_meta()
      ? *_impl_.subsystem_.meta_
      : reinterpret_cast< ::zmk::meta::Response&>(::zmk::meta::_Response_default_instance_);
}
inline const ::zmk::meta::Response& RequestResponse::meta() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.meta)
  return _internal_meta();
}
inline ::zmk::meta::Response* RequestResponse::unsafe_arena_release_meta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.meta)
  if (_internal_has_meta()) {
    clear_has_subsystem();
    ::zmk::meta::Response* temp = _impl_.subsystem_.meta_;
    _impl_.subsystem_.meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_meta(::zmk::meta::Response* meta) {
  clear_subsystem();
  if (meta) {
    set_has_meta();
    _impl_.subsystem_.meta_ = meta;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.meta)
}
inline ::zmk::meta::Response* RequestResponse::_internal_mutable_meta() {
  if (!_internal_has_meta()) {
    clear_subsystem();
    set_has_meta();
    _impl_.subsystem_.meta_ = CreateMaybeMessage< ::zmk::meta::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.meta_;
}
inline ::zmk::meta::Response* RequestResponse::mutable_meta() {
  ::zmk::meta::Response* _msg = _internal_mutable_meta();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.meta)
  return _msg;
}

// .zmk.core.Response core = 3;
inline bool RequestResponse::_internal_has_core() const {
  return subsystem_case() == kCore;
}
inline bool RequestResponse::has_core() const {
  return _internal_has_core();
}
inline void RequestResponse::set_has_core() {
  _impl_._oneof_case_[0] = kCore;
}
inline ::zmk::core::Response* RequestResponse::release_core() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Response* temp = _impl_.subsystem_.core_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::core::Response& RequestResponse::_internal_core() const {
  return _internal_has_core()
      ? *_impl_.subsystem_.core_
      : reinterpret_cast< ::zmk::core::Response&>(::zmk::core::_Response_default_instance_);
}
inline const ::zmk::core::Response& RequestResponse::core() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.core)
  return _internal_core();
}
inline ::zmk::core::Response* RequestResponse::unsafe_arena_release_core() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Response* temp = _impl_.subsystem_.core_;
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_core(::zmk::core::Response* core) {
  clear_subsystem();
  if (core) {
    set_has_core();
    _impl_.subsystem_.core_ = core;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.core)
}
inline ::zmk::core::Response* RequestResponse::_internal_mutable_core() {
  if (!_internal_has_core()) {
    clear_subsystem();
    set_has_core();
    _impl_.subsystem_.core_ = CreateMaybeMessage< ::zmk::core::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.core_;
}
inline ::zmk::core::Response* RequestResponse::mutable_core() {
  ::zmk::core::Response* _msg = _internal_mutable_core();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.core)
  return _msg;
}

// .zmk.behaviors.Response behaviors = 4;
inline bool RequestResponse::_internal_has_behaviors() const {
  return subsystem_case() == kBehaviors;
}
inline bool RequestResponse::has_behaviors() const {
  return _internal_has_behaviors();
}
inline void RequestResponse::set_has_behaviors() {
  _impl_._oneof_case_[0] = kBehaviors;
}
inline ::zmk::behaviors::Response* RequestResponse::release_behaviors() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.behaviors)
  if (_internal_has_behaviors()) {
    clear_has_subsystem();
    ::zmk::behaviors::Response* temp = _impl_.subsystem_.behaviors_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.behaviors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::behaviors::Response& RequestResponse::_internal_behaviors() const {
  return _internal_has_behaviors()
      ? *_impl_.subsystem_.behaviors_
      : reinterpret_cast< ::zmk::behaviors::Response&>(::zmk::behaviors::_Response_default_instance_);
}
inline const ::zmk::behaviors::Response& RequestResponse::behaviors() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.behaviors)
  return _internal_behaviors();
}
inline ::zmk::behaviors::Response* RequestResponse::unsafe_arena_release_behaviors() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.behaviors)
  if (_internal_has_behaviors()) {
    clear_has_subsystem();
    ::zmk::behaviors::Response* temp = _impl_.subsystem_.behaviors_;
    _impl_.subsystem_.behaviors_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_behaviors(::zmk::behaviors::Response* behaviors) {
  clear_subsystem();
  if (behaviors) {
    set_has_behaviors();
    _impl_.subsystem_.behaviors_ = behaviors;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.behaviors)
}
inline ::zmk::behaviors::Response* RequestResponse::_internal_mutable_behaviors() {
  if (!_internal_has_behaviors()) {
    clear_subsystem();
    set_has_behaviors();
    _impl_.subsystem_.behaviors_ = CreateMaybeMessage< ::zmk::behaviors::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.behaviors_;
}
inline ::zmk::behaviors::Response* RequestResponse::mutable_behaviors() {
  ::zmk::behaviors::Response* _msg = _internal_mutable_behaviors();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.behaviors)
  return _msg;
}

// .zmk.keymap.Response keymap = 5;
inline bool RequestResponse::_internal_has_keymap() const {
  return subsystem_case() == kKeymap;
}
inline bool RequestResponse::has_keymap() const {
  return _internal_has_keymap();
}
inline void RequestResponse::set_has_keymap() {
  _impl_._oneof_case_[0] = kKeymap;
}
inline ::zmk::keymap::Response* RequestResponse::release_keymap() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Response* temp = _impl_.subsystem_.keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Response& RequestResponse::_internal_keymap() const {
  return _internal_has_keymap()
      ? *_impl_.subsystem_.keymap_
      : reinterpret_cast< ::zmk::keymap::Response&>(::zmk::keymap::_Response_default_instance_);
}
inline const ::zmk::keymap::Response& RequestResponse::keymap() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.keymap)
  return _internal_keymap();
}
inline ::zmk::keymap::Response* RequestResponse::unsafe_arena_release_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Response* temp = _impl_.subsystem_.keymap_;
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_keymap(::zmk::keymap::Response* keymap) {
  clear_subsystem();
  if (keymap) {
    set_has_keymap();
    _impl_.subsystem_.keymap_ = keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.keymap)
}
inline ::zmk::keymap::Response* RequestResponse::_internal_mutable_keymap() {
  if (!_internal_has_keymap()) {
    clear_subsystem();
    set_has_keymap();
    _impl_.subsystem_.keymap_ = CreateMaybeMessage< ::zmk::keymap::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.keymap_;
}
inline ::zmk::keymap::Response* RequestResponse::mutable_keymap() {
  ::zmk::keymap::Response* _msg = _internal_mutable_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.keymap)
  return _msg;
}

// .zmk.led_settings.Response led_settings = 64;
inline bool RequestResponse::_internal_has_led_settings() const {
  return subsystem_case() == kLedSettings;
}
inline bool RequestResponse::has_led_settings() const {
  return _internal_has_led_settings();
}
inline void RequestResponse::set_has_led_settings() {
  _impl_._oneof_case_[0] = kLedSettings;
}
inline ::zmk::led_settings::Response* RequestResponse::release_led_settings() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.led_settings)
  if (_internal_has_led_settings()) {
    clear_has_subsystem();
    ::zmk::led_settings::Response* temp = _impl_.subsystem_.led_settings_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.led_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::led_settings::Response& RequestResponse::_internal_led_settings() const {
  return _internal_has_led_settings()
      ? *_impl_.subsystem_.led_settings_
      : reinterpret_cast< ::zmk::led_settings::Response&>(::zmk::led_settings::_Response_default_instance_);
}
inline const ::zmk::led_settings::Response& RequestResponse::led_settings() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.led_settings)
  return _internal_led_settings();
}
inline ::zmk::led_settings::Response* RequestResponse::unsafe_arena_release_led_settings() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.led_settings)
  if (_internal_has_led_settings()) {
    clear_has_subsystem();
    ::zmk::led_settings::Response* temp = _impl_.subsystem_.led_settings_;
    _impl_.subsystem_.led_settings_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_led_settings(::zmk::led_settings::Response* led_settings) {
  clear_subsystem();
  if (led_settings) {
    set_has_led_settings();
    _impl_.subsystem_.led_settings_ = led_settings;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.led_settings)
}
inline ::zmk::led_settings::Response* RequestResponse::_internal_mutable_led_settings() {
  if (!_internal_has_led_settings()) {
    clear_subsystem();
    set_has_led_settings();
    _impl_.subsystem_.led_settings_ = CreateMaybeMessage< ::zmk::led_settings::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.led_settings_;
}
inline ::zmk::led_settings::Response* RequestResponse::mutable_led_settings() {
  ::zmk::led_settings::Response* _msg = _internal_mutable_led_settings();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.led_settings)
  return _msg;
}

// .zmk.analog_keymap.Response analog_keymap = 65;
inline bool RequestResponse::_internal_has_analog_keymap() const {
  return subsystem_case() == kAnalogKeymap;
}
inline bool RequestResponse::has_analog_keymap() const {
  return _internal_has_analog_keymap();
}
inline void RequestResponse::set_has_analog_keymap() {
  _impl_._oneof_case_[0] = kAnalogKeymap;
}
inline ::zmk::analog_keymap::Response* RequestResponse::release_analog_keymap() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.analog_keymap)
  if (_internal_has_analog_keymap()) {
    clear_has_subsystem();
    ::zmk::analog_keymap::Response* temp = _impl_.subsystem_.analog_keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.analog_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::analog_keymap::Response& RequestResponse::_internal_analog_keymap() const {
  return _internal_has_analog_keymap()
      ? *_impl_.subsystem_.analog_keymap_
      : reinterpret_cast< ::zmk::analog_keymap::Response&>(::zmk::analog_keymap::_Response_default_instance_);
}
inline const ::zmk::analog_keymap::Response& RequestResponse::analog_keymap() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.analog_keymap)
  return _internal_analog_keymap();
}
inline ::zmk::analog_keymap::Response* RequestResponse::unsafe_arena_release_analog_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.analog_keymap)
  if (_internal_has_analog_keymap()) {
    clear_has_subsystem();
    ::zmk::analog_keymap::Response* temp = _impl_.subsystem_.analog_keymap_;
    _impl_.subsystem_.analog_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_analog_keymap(::zmk::analog_keymap::Response* analog_keymap) {
  clear_subsystem();
  if (analog_keymap) {
    set_has_analog_keymap();
    _impl_.subsystem_.analog_keymap_ = analog_keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.analog_keymap)
}
inline ::zmk::analog_keymap::Response* RequestResponse::_internal_mutable_analog_keymap() {
  if (!_internal_has_analog_keymap()) {
    clear_subsystem();
    set_has_analog_keymap();
    _impl_.subsystem_.analog_keymap_ = CreateMaybeMessage< ::zmk::analog_keymap::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.analog_keymap_;
}
inline ::zmk::analog_keymap::Response* RequestResponse::mutable_analog_keymap() {
  ::zmk::analog_keymap::Response* _msg = _internal_mutable_analog_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.analog_keymap)
  return _msg;
}

// .zmk.testing.Response testing = 66;
inline bool RequestResponse::_internal_has_testing() const {
  return subsystem_case() == kTesting;
}
inline bool RequestResponse::has_testing() const {
  return _internal_has_testing();
}
inline void RequestResponse::set_has_testing() {
  _impl_._oneof_case_[0] = kTesting;
}
inline ::zmk::testing::Response* RequestResponse::release_testing() {
  // @@protoc_insertion_point(field_release:zmk.studio.RequestResponse.testing)
  if (_internal_has_testing()) {
    clear_has_subsystem();
    ::zmk::testing::Response* temp = _impl_.subsystem_.testing_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.testing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::testing::Response& RequestResponse::_internal_testing() const {
  return _internal_has_testing()
      ? *_impl_.subsystem_.testing_
      : reinterpret_cast< ::zmk::testing::Response&>(::zmk::testing::_Response_default_instance_);
}
inline const ::zmk::testing::Response& RequestResponse::testing() const {
  // @@protoc_insertion_point(field_get:zmk.studio.RequestResponse.testing)
  return _internal_testing();
}
inline ::zmk::testing::Response* RequestResponse::unsafe_arena_release_testing() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.RequestResponse.testing)
  if (_internal_has_testing()) {
    clear_has_subsystem();
    ::zmk::testing::Response* temp = _impl_.subsystem_.testing_;
    _impl_.subsystem_.testing_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RequestResponse::unsafe_arena_set_allocated_testing(::zmk::testing::Response* testing) {
  clear_subsystem();
  if (testing) {
    set_has_testing();
    _impl_.subsystem_.testing_ = testing;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.RequestResponse.testing)
}
inline ::zmk::testing::Response* RequestResponse::_internal_mutable_testing() {
  if (!_internal_has_testing()) {
    clear_subsystem();
    set_has_testing();
    _impl_.subsystem_.testing_ = CreateMaybeMessage< ::zmk::testing::Response >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.testing_;
}
inline ::zmk::testing::Response* RequestResponse::mutable_testing() {
  ::zmk::testing::Response* _msg = _internal_mutable_testing();
  // @@protoc_insertion_point(field_mutable:zmk.studio.RequestResponse.testing)
  return _msg;
}

inline bool RequestResponse::has_subsystem() const {
  return subsystem_case() != SUBSYSTEM_NOT_SET;
}
inline void RequestResponse::clear_has_subsystem() {
  _impl_._oneof_case_[0] = SUBSYSTEM_NOT_SET;
}
inline RequestResponse::SubsystemCase RequestResponse::subsystem_case() const {
  return RequestResponse::SubsystemCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Notification

// .zmk.core.Notification core = 2;
inline bool Notification::_internal_has_core() const {
  return subsystem_case() == kCore;
}
inline bool Notification::has_core() const {
  return _internal_has_core();
}
inline void Notification::set_has_core() {
  _impl_._oneof_case_[0] = kCore;
}
inline ::zmk::core::Notification* Notification::release_core() {
  // @@protoc_insertion_point(field_release:zmk.studio.Notification.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Notification* temp = _impl_.subsystem_.core_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::core::Notification& Notification::_internal_core() const {
  return _internal_has_core()
      ? *_impl_.subsystem_.core_
      : reinterpret_cast< ::zmk::core::Notification&>(::zmk::core::_Notification_default_instance_);
}
inline const ::zmk::core::Notification& Notification::core() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Notification.core)
  return _internal_core();
}
inline ::zmk::core::Notification* Notification::unsafe_arena_release_core() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Notification.core)
  if (_internal_has_core()) {
    clear_has_subsystem();
    ::zmk::core::Notification* temp = _impl_.subsystem_.core_;
    _impl_.subsystem_.core_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Notification::unsafe_arena_set_allocated_core(::zmk::core::Notification* core) {
  clear_subsystem();
  if (core) {
    set_has_core();
    _impl_.subsystem_.core_ = core;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Notification.core)
}
inline ::zmk::core::Notification* Notification::_internal_mutable_core() {
  if (!_internal_has_core()) {
    clear_subsystem();
    set_has_core();
    _impl_.subsystem_.core_ = CreateMaybeMessage< ::zmk::core::Notification >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.core_;
}
inline ::zmk::core::Notification* Notification::mutable_core() {
  ::zmk::core::Notification* _msg = _internal_mutable_core();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Notification.core)
  return _msg;
}

// .zmk.keymap.Notification keymap = 5;
inline bool Notification::_internal_has_keymap() const {
  return subsystem_case() == kKeymap;
}
inline bool Notification::has_keymap() const {
  return _internal_has_keymap();
}
inline void Notification::set_has_keymap() {
  _impl_._oneof_case_[0] = kKeymap;
}
inline ::zmk::keymap::Notification* Notification::release_keymap() {
  // @@protoc_insertion_point(field_release:zmk.studio.Notification.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Notification* temp = _impl_.subsystem_.keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Notification& Notification::_internal_keymap() const {
  return _internal_has_keymap()
      ? *_impl_.subsystem_.keymap_
      : reinterpret_cast< ::zmk::keymap::Notification&>(::zmk::keymap::_Notification_default_instance_);
}
inline const ::zmk::keymap::Notification& Notification::keymap() const {
  // @@protoc_insertion_point(field_get:zmk.studio.Notification.keymap)
  return _internal_keymap();
}
inline ::zmk::keymap::Notification* Notification::unsafe_arena_release_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.studio.Notification.keymap)
  if (_internal_has_keymap()) {
    clear_has_subsystem();
    ::zmk::keymap::Notification* temp = _impl_.subsystem_.keymap_;
    _impl_.subsystem_.keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Notification::unsafe_arena_set_allocated_keymap(::zmk::keymap::Notification* keymap) {
  clear_subsystem();
  if (keymap) {
    set_has_keymap();
    _impl_.subsystem_.keymap_ = keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.studio.Notification.keymap)
}
inline ::zmk::keymap::Notification* Notification::_internal_mutable_keymap() {
  if (!_internal_has_keymap()) {
    clear_subsystem();
    set_has_keymap();
    _impl_.subsystem_.keymap_ = CreateMaybeMessage< ::zmk::keymap::Notification >(GetArenaForAllocation());
  }
  return _impl_.subsystem_.keymap_;
}
inline ::zmk::keymap::Notification* Notification::mutable_keymap() {
  ::zmk::keymap::Notification* _msg = _internal_mutable_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.studio.Notification.keymap)
  return _msg;
}

inline bool Notification::has_subsystem() const {
  return subsystem_case() != SUBSYSTEM_NOT_SET;
}
inline void Notification::clear_has_subsystem() {
  _impl_._oneof_case_[0] = SUBSYSTEM_NOT_SET;
}
inline Notification::SubsystemCase Notification::subsystem_case() const {
  return Notification::SubsystemCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace studio
}  // namespace zmk

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_studio_2eproto
