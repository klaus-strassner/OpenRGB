// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: keymap.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_keymap_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_keymap_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_keymap_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_keymap_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_keymap_2eproto;
namespace zmk {
namespace keymap {
class AddLayerRequest;
struct AddLayerRequestDefaultTypeInternal;
extern AddLayerRequestDefaultTypeInternal _AddLayerRequest_default_instance_;
class AddLayerResponse;
struct AddLayerResponseDefaultTypeInternal;
extern AddLayerResponseDefaultTypeInternal _AddLayerResponse_default_instance_;
class AddLayerResponseDetails;
struct AddLayerResponseDetailsDefaultTypeInternal;
extern AddLayerResponseDetailsDefaultTypeInternal _AddLayerResponseDetails_default_instance_;
class BehaviorBinding;
struct BehaviorBindingDefaultTypeInternal;
extern BehaviorBindingDefaultTypeInternal _BehaviorBinding_default_instance_;
class KeyPhysicalAttrs;
struct KeyPhysicalAttrsDefaultTypeInternal;
extern KeyPhysicalAttrsDefaultTypeInternal _KeyPhysicalAttrs_default_instance_;
class Keymap;
struct KeymapDefaultTypeInternal;
extern KeymapDefaultTypeInternal _Keymap_default_instance_;
class Layer;
struct LayerDefaultTypeInternal;
extern LayerDefaultTypeInternal _Layer_default_instance_;
class MoveLayerRequest;
struct MoveLayerRequestDefaultTypeInternal;
extern MoveLayerRequestDefaultTypeInternal _MoveLayerRequest_default_instance_;
class MoveLayerResponse;
struct MoveLayerResponseDefaultTypeInternal;
extern MoveLayerResponseDefaultTypeInternal _MoveLayerResponse_default_instance_;
class Notification;
struct NotificationDefaultTypeInternal;
extern NotificationDefaultTypeInternal _Notification_default_instance_;
class PhysicalLayout;
struct PhysicalLayoutDefaultTypeInternal;
extern PhysicalLayoutDefaultTypeInternal _PhysicalLayout_default_instance_;
class PhysicalLayouts;
struct PhysicalLayoutsDefaultTypeInternal;
extern PhysicalLayoutsDefaultTypeInternal _PhysicalLayouts_default_instance_;
class RemoveLayerOk;
struct RemoveLayerOkDefaultTypeInternal;
extern RemoveLayerOkDefaultTypeInternal _RemoveLayerOk_default_instance_;
class RemoveLayerRequest;
struct RemoveLayerRequestDefaultTypeInternal;
extern RemoveLayerRequestDefaultTypeInternal _RemoveLayerRequest_default_instance_;
class RemoveLayerResponse;
struct RemoveLayerResponseDefaultTypeInternal;
extern RemoveLayerResponseDefaultTypeInternal _RemoveLayerResponse_default_instance_;
class Request;
struct RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RestoreLayerRequest;
struct RestoreLayerRequestDefaultTypeInternal;
extern RestoreLayerRequestDefaultTypeInternal _RestoreLayerRequest_default_instance_;
class RestoreLayerResponse;
struct RestoreLayerResponseDefaultTypeInternal;
extern RestoreLayerResponseDefaultTypeInternal _RestoreLayerResponse_default_instance_;
class SaveChangesResponse;
struct SaveChangesResponseDefaultTypeInternal;
extern SaveChangesResponseDefaultTypeInternal _SaveChangesResponse_default_instance_;
class SetActivePhysicalLayoutResponse;
struct SetActivePhysicalLayoutResponseDefaultTypeInternal;
extern SetActivePhysicalLayoutResponseDefaultTypeInternal _SetActivePhysicalLayoutResponse_default_instance_;
class SetLayerBindingRequest;
struct SetLayerBindingRequestDefaultTypeInternal;
extern SetLayerBindingRequestDefaultTypeInternal _SetLayerBindingRequest_default_instance_;
class SetLayerPropsRequest;
struct SetLayerPropsRequestDefaultTypeInternal;
extern SetLayerPropsRequestDefaultTypeInternal _SetLayerPropsRequest_default_instance_;
}  // namespace keymap
}  // namespace zmk
PROTOBUF_NAMESPACE_OPEN
template<> ::zmk::keymap::AddLayerRequest* Arena::CreateMaybeMessage<::zmk::keymap::AddLayerRequest>(Arena*);
template<> ::zmk::keymap::AddLayerResponse* Arena::CreateMaybeMessage<::zmk::keymap::AddLayerResponse>(Arena*);
template<> ::zmk::keymap::AddLayerResponseDetails* Arena::CreateMaybeMessage<::zmk::keymap::AddLayerResponseDetails>(Arena*);
template<> ::zmk::keymap::BehaviorBinding* Arena::CreateMaybeMessage<::zmk::keymap::BehaviorBinding>(Arena*);
template<> ::zmk::keymap::KeyPhysicalAttrs* Arena::CreateMaybeMessage<::zmk::keymap::KeyPhysicalAttrs>(Arena*);
template<> ::zmk::keymap::Keymap* Arena::CreateMaybeMessage<::zmk::keymap::Keymap>(Arena*);
template<> ::zmk::keymap::Layer* Arena::CreateMaybeMessage<::zmk::keymap::Layer>(Arena*);
template<> ::zmk::keymap::MoveLayerRequest* Arena::CreateMaybeMessage<::zmk::keymap::MoveLayerRequest>(Arena*);
template<> ::zmk::keymap::MoveLayerResponse* Arena::CreateMaybeMessage<::zmk::keymap::MoveLayerResponse>(Arena*);
template<> ::zmk::keymap::Notification* Arena::CreateMaybeMessage<::zmk::keymap::Notification>(Arena*);
template<> ::zmk::keymap::PhysicalLayout* Arena::CreateMaybeMessage<::zmk::keymap::PhysicalLayout>(Arena*);
template<> ::zmk::keymap::PhysicalLayouts* Arena::CreateMaybeMessage<::zmk::keymap::PhysicalLayouts>(Arena*);
template<> ::zmk::keymap::RemoveLayerOk* Arena::CreateMaybeMessage<::zmk::keymap::RemoveLayerOk>(Arena*);
template<> ::zmk::keymap::RemoveLayerRequest* Arena::CreateMaybeMessage<::zmk::keymap::RemoveLayerRequest>(Arena*);
template<> ::zmk::keymap::RemoveLayerResponse* Arena::CreateMaybeMessage<::zmk::keymap::RemoveLayerResponse>(Arena*);
template<> ::zmk::keymap::Request* Arena::CreateMaybeMessage<::zmk::keymap::Request>(Arena*);
template<> ::zmk::keymap::Response* Arena::CreateMaybeMessage<::zmk::keymap::Response>(Arena*);
template<> ::zmk::keymap::RestoreLayerRequest* Arena::CreateMaybeMessage<::zmk::keymap::RestoreLayerRequest>(Arena*);
template<> ::zmk::keymap::RestoreLayerResponse* Arena::CreateMaybeMessage<::zmk::keymap::RestoreLayerResponse>(Arena*);
template<> ::zmk::keymap::SaveChangesResponse* Arena::CreateMaybeMessage<::zmk::keymap::SaveChangesResponse>(Arena*);
template<> ::zmk::keymap::SetActivePhysicalLayoutResponse* Arena::CreateMaybeMessage<::zmk::keymap::SetActivePhysicalLayoutResponse>(Arena*);
template<> ::zmk::keymap::SetLayerBindingRequest* Arena::CreateMaybeMessage<::zmk::keymap::SetLayerBindingRequest>(Arena*);
template<> ::zmk::keymap::SetLayerPropsRequest* Arena::CreateMaybeMessage<::zmk::keymap::SetLayerPropsRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace zmk {
namespace keymap {

enum SaveChangesErrorCode : int {
  SAVE_CHANGES_ERR_OK = 0,
  SAVE_CHANGES_ERR_GENERIC = 1,
  SAVE_CHANGES_ERR_NOT_SUPPORTED = 2,
  SAVE_CHANGES_ERR_NO_SPACE = 3,
  SaveChangesErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SaveChangesErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SaveChangesErrorCode_IsValid(int value);
constexpr SaveChangesErrorCode SaveChangesErrorCode_MIN = SAVE_CHANGES_ERR_OK;
constexpr SaveChangesErrorCode SaveChangesErrorCode_MAX = SAVE_CHANGES_ERR_NO_SPACE;
constexpr int SaveChangesErrorCode_ARRAYSIZE = SaveChangesErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SaveChangesErrorCode_descriptor();
template<typename T>
inline const std::string& SaveChangesErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SaveChangesErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SaveChangesErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SaveChangesErrorCode_descriptor(), enum_t_value);
}
inline bool SaveChangesErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SaveChangesErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SaveChangesErrorCode>(
    SaveChangesErrorCode_descriptor(), name, value);
}
enum SetLayerBindingResponse : int {
  SET_LAYER_BINDING_RESP_OK = 0,
  SET_LAYER_BINDING_RESP_INVALID_LOCATION = 1,
  SET_LAYER_BINDING_RESP_INVALID_BEHAVIOR = 2,
  SET_LAYER_BINDING_RESP_INVALID_PARAMETERS = 3,
  SetLayerBindingResponse_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetLayerBindingResponse_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetLayerBindingResponse_IsValid(int value);
constexpr SetLayerBindingResponse SetLayerBindingResponse_MIN = SET_LAYER_BINDING_RESP_OK;
constexpr SetLayerBindingResponse SetLayerBindingResponse_MAX = SET_LAYER_BINDING_RESP_INVALID_PARAMETERS;
constexpr int SetLayerBindingResponse_ARRAYSIZE = SetLayerBindingResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetLayerBindingResponse_descriptor();
template<typename T>
inline const std::string& SetLayerBindingResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetLayerBindingResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetLayerBindingResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetLayerBindingResponse_descriptor(), enum_t_value);
}
inline bool SetLayerBindingResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetLayerBindingResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetLayerBindingResponse>(
    SetLayerBindingResponse_descriptor(), name, value);
}
enum MoveLayerErrorCode : int {
  MOVE_LAYER_ERR_OK = 0,
  MOVE_LAYER_ERR_GENERIC = 1,
  MOVE_LAYER_ERR_INVALID_LAYER = 2,
  MOVE_LAYER_ERR_INVALID_DESTINATION = 3,
  MoveLayerErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MoveLayerErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MoveLayerErrorCode_IsValid(int value);
constexpr MoveLayerErrorCode MoveLayerErrorCode_MIN = MOVE_LAYER_ERR_OK;
constexpr MoveLayerErrorCode MoveLayerErrorCode_MAX = MOVE_LAYER_ERR_INVALID_DESTINATION;
constexpr int MoveLayerErrorCode_ARRAYSIZE = MoveLayerErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MoveLayerErrorCode_descriptor();
template<typename T>
inline const std::string& MoveLayerErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MoveLayerErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MoveLayerErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MoveLayerErrorCode_descriptor(), enum_t_value);
}
inline bool MoveLayerErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MoveLayerErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MoveLayerErrorCode>(
    MoveLayerErrorCode_descriptor(), name, value);
}
enum AddLayerErrorCode : int {
  ADD_LAYER_ERR_OK = 0,
  ADD_LAYER_ERR_GENERIC = 1,
  ADD_LAYER_ERR_NO_SPACE = 2,
  AddLayerErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AddLayerErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AddLayerErrorCode_IsValid(int value);
constexpr AddLayerErrorCode AddLayerErrorCode_MIN = ADD_LAYER_ERR_OK;
constexpr AddLayerErrorCode AddLayerErrorCode_MAX = ADD_LAYER_ERR_NO_SPACE;
constexpr int AddLayerErrorCode_ARRAYSIZE = AddLayerErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AddLayerErrorCode_descriptor();
template<typename T>
inline const std::string& AddLayerErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AddLayerErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AddLayerErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AddLayerErrorCode_descriptor(), enum_t_value);
}
inline bool AddLayerErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AddLayerErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AddLayerErrorCode>(
    AddLayerErrorCode_descriptor(), name, value);
}
enum RemoveLayerErrorCode : int {
  REMOVE_LAYER_ERR_OK = 0,
  REMOVE_LAYER_ERR_GENERIC = 1,
  REMOVE_LAYER_ERR_INVALID_INDEX = 2,
  RemoveLayerErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RemoveLayerErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RemoveLayerErrorCode_IsValid(int value);
constexpr RemoveLayerErrorCode RemoveLayerErrorCode_MIN = REMOVE_LAYER_ERR_OK;
constexpr RemoveLayerErrorCode RemoveLayerErrorCode_MAX = REMOVE_LAYER_ERR_INVALID_INDEX;
constexpr int RemoveLayerErrorCode_ARRAYSIZE = RemoveLayerErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RemoveLayerErrorCode_descriptor();
template<typename T>
inline const std::string& RemoveLayerErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RemoveLayerErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RemoveLayerErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RemoveLayerErrorCode_descriptor(), enum_t_value);
}
inline bool RemoveLayerErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RemoveLayerErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RemoveLayerErrorCode>(
    RemoveLayerErrorCode_descriptor(), name, value);
}
enum RestoreLayerErrorCode : int {
  RESTORE_LAYER_ERR_OK = 0,
  RESTORE_LAYER_ERR_GENERIC = 1,
  RESTORE_LAYER_ERR_INVALID_ID = 2,
  RESTORE_LAYER_ERR_INVALID_INDEX = 3,
  RestoreLayerErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RestoreLayerErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RestoreLayerErrorCode_IsValid(int value);
constexpr RestoreLayerErrorCode RestoreLayerErrorCode_MIN = RESTORE_LAYER_ERR_OK;
constexpr RestoreLayerErrorCode RestoreLayerErrorCode_MAX = RESTORE_LAYER_ERR_INVALID_INDEX;
constexpr int RestoreLayerErrorCode_ARRAYSIZE = RestoreLayerErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RestoreLayerErrorCode_descriptor();
template<typename T>
inline const std::string& RestoreLayerErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RestoreLayerErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RestoreLayerErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RestoreLayerErrorCode_descriptor(), enum_t_value);
}
inline bool RestoreLayerErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RestoreLayerErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RestoreLayerErrorCode>(
    RestoreLayerErrorCode_descriptor(), name, value);
}
enum SetLayerPropsResponse : int {
  SET_LAYER_PROPS_RESP_OK = 0,
  SET_LAYER_PROPS_RESP_ERR_GENERIC = 1,
  SET_LAYER_PROPS_RESP_ERR_INVALID_ID = 2,
  SetLayerPropsResponse_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetLayerPropsResponse_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetLayerPropsResponse_IsValid(int value);
constexpr SetLayerPropsResponse SetLayerPropsResponse_MIN = SET_LAYER_PROPS_RESP_OK;
constexpr SetLayerPropsResponse SetLayerPropsResponse_MAX = SET_LAYER_PROPS_RESP_ERR_INVALID_ID;
constexpr int SetLayerPropsResponse_ARRAYSIZE = SetLayerPropsResponse_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetLayerPropsResponse_descriptor();
template<typename T>
inline const std::string& SetLayerPropsResponse_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetLayerPropsResponse>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetLayerPropsResponse_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetLayerPropsResponse_descriptor(), enum_t_value);
}
inline bool SetLayerPropsResponse_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetLayerPropsResponse* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetLayerPropsResponse>(
    SetLayerPropsResponse_descriptor(), name, value);
}
enum SetActivePhysicalLayoutErrorCode : int {
  SET_ACTIVE_PHYSICAL_LAYOUT_ERR_OK = 0,
  SET_ACTIVE_PHYSICAL_LAYOUT_ERR_GENERIC = 1,
  SET_ACTIVE_PHYSICAL_LAYOUT_ERR_INVALID_LAYOUT_INDEX = 2,
  SetActivePhysicalLayoutErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SetActivePhysicalLayoutErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SetActivePhysicalLayoutErrorCode_IsValid(int value);
constexpr SetActivePhysicalLayoutErrorCode SetActivePhysicalLayoutErrorCode_MIN = SET_ACTIVE_PHYSICAL_LAYOUT_ERR_OK;
constexpr SetActivePhysicalLayoutErrorCode SetActivePhysicalLayoutErrorCode_MAX = SET_ACTIVE_PHYSICAL_LAYOUT_ERR_INVALID_LAYOUT_INDEX;
constexpr int SetActivePhysicalLayoutErrorCode_ARRAYSIZE = SetActivePhysicalLayoutErrorCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SetActivePhysicalLayoutErrorCode_descriptor();
template<typename T>
inline const std::string& SetActivePhysicalLayoutErrorCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SetActivePhysicalLayoutErrorCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SetActivePhysicalLayoutErrorCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SetActivePhysicalLayoutErrorCode_descriptor(), enum_t_value);
}
inline bool SetActivePhysicalLayoutErrorCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SetActivePhysicalLayoutErrorCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SetActivePhysicalLayoutErrorCode>(
    SetActivePhysicalLayoutErrorCode_descriptor(), name, value);
}
// ===================================================================

class Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.Request) */ {
 public:
  inline Request() : Request(nullptr) {}
  ~Request() override;
  explicit PROTOBUF_CONSTEXPR Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Request(const Request& from);
  Request(Request&& from) noexcept
    : Request() {
    *this = ::std::move(from);
  }

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Request& operator=(Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Request& default_instance() {
    return *internal_default_instance();
  }
  enum RequestTypeCase {
    kGetKeymap = 1,
    kSetLayerBinding = 2,
    kCheckUnsavedChanges = 3,
    kSaveChanges = 4,
    kDiscardChanges = 5,
    kGetPhysicalLayouts = 6,
    kSetActivePhysicalLayout = 7,
    kMoveLayer = 8,
    kAddLayer = 9,
    kRemoveLayer = 10,
    kRestoreLayer = 11,
    kSetLayerProps = 12,
    REQUEST_TYPE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Request& a, Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Request& from) {
    Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.Request";
  }
  protected:
  explicit Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetKeymapFieldNumber = 1,
    kSetLayerBindingFieldNumber = 2,
    kCheckUnsavedChangesFieldNumber = 3,
    kSaveChangesFieldNumber = 4,
    kDiscardChangesFieldNumber = 5,
    kGetPhysicalLayoutsFieldNumber = 6,
    kSetActivePhysicalLayoutFieldNumber = 7,
    kMoveLayerFieldNumber = 8,
    kAddLayerFieldNumber = 9,
    kRemoveLayerFieldNumber = 10,
    kRestoreLayerFieldNumber = 11,
    kSetLayerPropsFieldNumber = 12,
  };
  // bool get_keymap = 1;
  bool has_get_keymap() const;
  private:
  bool _internal_has_get_keymap() const;
  public:
  void clear_get_keymap();
  bool get_keymap() const;
  void set_get_keymap(bool value);
  private:
  bool _internal_get_keymap() const;
  void _internal_set_get_keymap(bool value);
  public:

  // .zmk.keymap.SetLayerBindingRequest set_layer_binding = 2;
  bool has_set_layer_binding() const;
  private:
  bool _internal_has_set_layer_binding() const;
  public:
  void clear_set_layer_binding();
  const ::zmk::keymap::SetLayerBindingRequest& set_layer_binding() const;
  PROTOBUF_NODISCARD ::zmk::keymap::SetLayerBindingRequest* release_set_layer_binding();
  ::zmk::keymap::SetLayerBindingRequest* mutable_set_layer_binding();
  void set_allocated_set_layer_binding(::zmk::keymap::SetLayerBindingRequest* set_layer_binding);
  private:
  const ::zmk::keymap::SetLayerBindingRequest& _internal_set_layer_binding() const;
  ::zmk::keymap::SetLayerBindingRequest* _internal_mutable_set_layer_binding();
  public:
  void unsafe_arena_set_allocated_set_layer_binding(
      ::zmk::keymap::SetLayerBindingRequest* set_layer_binding);
  ::zmk::keymap::SetLayerBindingRequest* unsafe_arena_release_set_layer_binding();

  // bool check_unsaved_changes = 3;
  bool has_check_unsaved_changes() const;
  private:
  bool _internal_has_check_unsaved_changes() const;
  public:
  void clear_check_unsaved_changes();
  bool check_unsaved_changes() const;
  void set_check_unsaved_changes(bool value);
  private:
  bool _internal_check_unsaved_changes() const;
  void _internal_set_check_unsaved_changes(bool value);
  public:

  // bool save_changes = 4;
  bool has_save_changes() const;
  private:
  bool _internal_has_save_changes() const;
  public:
  void clear_save_changes();
  bool save_changes() const;
  void set_save_changes(bool value);
  private:
  bool _internal_save_changes() const;
  void _internal_set_save_changes(bool value);
  public:

  // bool discard_changes = 5;
  bool has_discard_changes() const;
  private:
  bool _internal_has_discard_changes() const;
  public:
  void clear_discard_changes();
  bool discard_changes() const;
  void set_discard_changes(bool value);
  private:
  bool _internal_discard_changes() const;
  void _internal_set_discard_changes(bool value);
  public:

  // bool get_physical_layouts = 6;
  bool has_get_physical_layouts() const;
  private:
  bool _internal_has_get_physical_layouts() const;
  public:
  void clear_get_physical_layouts();
  bool get_physical_layouts() const;
  void set_get_physical_layouts(bool value);
  private:
  bool _internal_get_physical_layouts() const;
  void _internal_set_get_physical_layouts(bool value);
  public:

  // uint32 set_active_physical_layout = 7;
  bool has_set_active_physical_layout() const;
  private:
  bool _internal_has_set_active_physical_layout() const;
  public:
  void clear_set_active_physical_layout();
  uint32_t set_active_physical_layout() const;
  void set_set_active_physical_layout(uint32_t value);
  private:
  uint32_t _internal_set_active_physical_layout() const;
  void _internal_set_set_active_physical_layout(uint32_t value);
  public:

  // .zmk.keymap.MoveLayerRequest move_layer = 8;
  bool has_move_layer() const;
  private:
  bool _internal_has_move_layer() const;
  public:
  void clear_move_layer();
  const ::zmk::keymap::MoveLayerRequest& move_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::MoveLayerRequest* release_move_layer();
  ::zmk::keymap::MoveLayerRequest* mutable_move_layer();
  void set_allocated_move_layer(::zmk::keymap::MoveLayerRequest* move_layer);
  private:
  const ::zmk::keymap::MoveLayerRequest& _internal_move_layer() const;
  ::zmk::keymap::MoveLayerRequest* _internal_mutable_move_layer();
  public:
  void unsafe_arena_set_allocated_move_layer(
      ::zmk::keymap::MoveLayerRequest* move_layer);
  ::zmk::keymap::MoveLayerRequest* unsafe_arena_release_move_layer();

  // .zmk.keymap.AddLayerRequest add_layer = 9;
  bool has_add_layer() const;
  private:
  bool _internal_has_add_layer() const;
  public:
  void clear_add_layer();
  const ::zmk::keymap::AddLayerRequest& add_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::AddLayerRequest* release_add_layer();
  ::zmk::keymap::AddLayerRequest* mutable_add_layer();
  void set_allocated_add_layer(::zmk::keymap::AddLayerRequest* add_layer);
  private:
  const ::zmk::keymap::AddLayerRequest& _internal_add_layer() const;
  ::zmk::keymap::AddLayerRequest* _internal_mutable_add_layer();
  public:
  void unsafe_arena_set_allocated_add_layer(
      ::zmk::keymap::AddLayerRequest* add_layer);
  ::zmk::keymap::AddLayerRequest* unsafe_arena_release_add_layer();

  // .zmk.keymap.RemoveLayerRequest remove_layer = 10;
  bool has_remove_layer() const;
  private:
  bool _internal_has_remove_layer() const;
  public:
  void clear_remove_layer();
  const ::zmk::keymap::RemoveLayerRequest& remove_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::RemoveLayerRequest* release_remove_layer();
  ::zmk::keymap::RemoveLayerRequest* mutable_remove_layer();
  void set_allocated_remove_layer(::zmk::keymap::RemoveLayerRequest* remove_layer);
  private:
  const ::zmk::keymap::RemoveLayerRequest& _internal_remove_layer() const;
  ::zmk::keymap::RemoveLayerRequest* _internal_mutable_remove_layer();
  public:
  void unsafe_arena_set_allocated_remove_layer(
      ::zmk::keymap::RemoveLayerRequest* remove_layer);
  ::zmk::keymap::RemoveLayerRequest* unsafe_arena_release_remove_layer();

  // .zmk.keymap.RestoreLayerRequest restore_layer = 11;
  bool has_restore_layer() const;
  private:
  bool _internal_has_restore_layer() const;
  public:
  void clear_restore_layer();
  const ::zmk::keymap::RestoreLayerRequest& restore_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::RestoreLayerRequest* release_restore_layer();
  ::zmk::keymap::RestoreLayerRequest* mutable_restore_layer();
  void set_allocated_restore_layer(::zmk::keymap::RestoreLayerRequest* restore_layer);
  private:
  const ::zmk::keymap::RestoreLayerRequest& _internal_restore_layer() const;
  ::zmk::keymap::RestoreLayerRequest* _internal_mutable_restore_layer();
  public:
  void unsafe_arena_set_allocated_restore_layer(
      ::zmk::keymap::RestoreLayerRequest* restore_layer);
  ::zmk::keymap::RestoreLayerRequest* unsafe_arena_release_restore_layer();

  // .zmk.keymap.SetLayerPropsRequest set_layer_props = 12;
  bool has_set_layer_props() const;
  private:
  bool _internal_has_set_layer_props() const;
  public:
  void clear_set_layer_props();
  const ::zmk::keymap::SetLayerPropsRequest& set_layer_props() const;
  PROTOBUF_NODISCARD ::zmk::keymap::SetLayerPropsRequest* release_set_layer_props();
  ::zmk::keymap::SetLayerPropsRequest* mutable_set_layer_props();
  void set_allocated_set_layer_props(::zmk::keymap::SetLayerPropsRequest* set_layer_props);
  private:
  const ::zmk::keymap::SetLayerPropsRequest& _internal_set_layer_props() const;
  ::zmk::keymap::SetLayerPropsRequest* _internal_mutable_set_layer_props();
  public:
  void unsafe_arena_set_allocated_set_layer_props(
      ::zmk::keymap::SetLayerPropsRequest* set_layer_props);
  ::zmk::keymap::SetLayerPropsRequest* unsafe_arena_release_set_layer_props();

  void clear_request_type();
  RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.Request)
 private:
  class _Internal;
  void set_has_get_keymap();
  void set_has_set_layer_binding();
  void set_has_check_unsaved_changes();
  void set_has_save_changes();
  void set_has_discard_changes();
  void set_has_get_physical_layouts();
  void set_has_set_active_physical_layout();
  void set_has_move_layer();
  void set_has_add_layer();
  void set_has_remove_layer();
  void set_has_restore_layer();
  void set_has_set_layer_props();

  inline bool has_request_type() const;
  inline void clear_has_request_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union RequestTypeUnion {
      constexpr RequestTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool get_keymap_;
      ::zmk::keymap::SetLayerBindingRequest* set_layer_binding_;
      bool check_unsaved_changes_;
      bool save_changes_;
      bool discard_changes_;
      bool get_physical_layouts_;
      uint32_t set_active_physical_layout_;
      ::zmk::keymap::MoveLayerRequest* move_layer_;
      ::zmk::keymap::AddLayerRequest* add_layer_;
      ::zmk::keymap::RemoveLayerRequest* remove_layer_;
      ::zmk::keymap::RestoreLayerRequest* restore_layer_;
      ::zmk::keymap::SetLayerPropsRequest* set_layer_props_;
    } request_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit PROTOBUF_CONSTEXPR Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseTypeCase {
    kGetKeymap = 1,
    kSetLayerBinding = 2,
    kCheckUnsavedChanges = 3,
    kSaveChanges = 4,
    kDiscardChanges = 5,
    kGetPhysicalLayouts = 6,
    kSetActivePhysicalLayout = 7,
    kMoveLayer = 8,
    kAddLayer = 9,
    kRemoveLayer = 10,
    kRestoreLayer = 11,
    kSetLayerProps = 12,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Response& from) {
    Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGetKeymapFieldNumber = 1,
    kSetLayerBindingFieldNumber = 2,
    kCheckUnsavedChangesFieldNumber = 3,
    kSaveChangesFieldNumber = 4,
    kDiscardChangesFieldNumber = 5,
    kGetPhysicalLayoutsFieldNumber = 6,
    kSetActivePhysicalLayoutFieldNumber = 7,
    kMoveLayerFieldNumber = 8,
    kAddLayerFieldNumber = 9,
    kRemoveLayerFieldNumber = 10,
    kRestoreLayerFieldNumber = 11,
    kSetLayerPropsFieldNumber = 12,
  };
  // .zmk.keymap.Keymap get_keymap = 1;
  bool has_get_keymap() const;
  private:
  bool _internal_has_get_keymap() const;
  public:
  void clear_get_keymap();
  const ::zmk::keymap::Keymap& get_keymap() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Keymap* release_get_keymap();
  ::zmk::keymap::Keymap* mutable_get_keymap();
  void set_allocated_get_keymap(::zmk::keymap::Keymap* get_keymap);
  private:
  const ::zmk::keymap::Keymap& _internal_get_keymap() const;
  ::zmk::keymap::Keymap* _internal_mutable_get_keymap();
  public:
  void unsafe_arena_set_allocated_get_keymap(
      ::zmk::keymap::Keymap* get_keymap);
  ::zmk::keymap::Keymap* unsafe_arena_release_get_keymap();

  // .zmk.keymap.SetLayerBindingResponse set_layer_binding = 2;
  bool has_set_layer_binding() const;
  private:
  bool _internal_has_set_layer_binding() const;
  public:
  void clear_set_layer_binding();
  ::zmk::keymap::SetLayerBindingResponse set_layer_binding() const;
  void set_set_layer_binding(::zmk::keymap::SetLayerBindingResponse value);
  private:
  ::zmk::keymap::SetLayerBindingResponse _internal_set_layer_binding() const;
  void _internal_set_set_layer_binding(::zmk::keymap::SetLayerBindingResponse value);
  public:

  // bool check_unsaved_changes = 3;
  bool has_check_unsaved_changes() const;
  private:
  bool _internal_has_check_unsaved_changes() const;
  public:
  void clear_check_unsaved_changes();
  bool check_unsaved_changes() const;
  void set_check_unsaved_changes(bool value);
  private:
  bool _internal_check_unsaved_changes() const;
  void _internal_set_check_unsaved_changes(bool value);
  public:

  // .zmk.keymap.SaveChangesResponse save_changes = 4;
  bool has_save_changes() const;
  private:
  bool _internal_has_save_changes() const;
  public:
  void clear_save_changes();
  const ::zmk::keymap::SaveChangesResponse& save_changes() const;
  PROTOBUF_NODISCARD ::zmk::keymap::SaveChangesResponse* release_save_changes();
  ::zmk::keymap::SaveChangesResponse* mutable_save_changes();
  void set_allocated_save_changes(::zmk::keymap::SaveChangesResponse* save_changes);
  private:
  const ::zmk::keymap::SaveChangesResponse& _internal_save_changes() const;
  ::zmk::keymap::SaveChangesResponse* _internal_mutable_save_changes();
  public:
  void unsafe_arena_set_allocated_save_changes(
      ::zmk::keymap::SaveChangesResponse* save_changes);
  ::zmk::keymap::SaveChangesResponse* unsafe_arena_release_save_changes();

  // bool discard_changes = 5;
  bool has_discard_changes() const;
  private:
  bool _internal_has_discard_changes() const;
  public:
  void clear_discard_changes();
  bool discard_changes() const;
  void set_discard_changes(bool value);
  private:
  bool _internal_discard_changes() const;
  void _internal_set_discard_changes(bool value);
  public:

  // .zmk.keymap.PhysicalLayouts get_physical_layouts = 6;
  bool has_get_physical_layouts() const;
  private:
  bool _internal_has_get_physical_layouts() const;
  public:
  void clear_get_physical_layouts();
  const ::zmk::keymap::PhysicalLayouts& get_physical_layouts() const;
  PROTOBUF_NODISCARD ::zmk::keymap::PhysicalLayouts* release_get_physical_layouts();
  ::zmk::keymap::PhysicalLayouts* mutable_get_physical_layouts();
  void set_allocated_get_physical_layouts(::zmk::keymap::PhysicalLayouts* get_physical_layouts);
  private:
  const ::zmk::keymap::PhysicalLayouts& _internal_get_physical_layouts() const;
  ::zmk::keymap::PhysicalLayouts* _internal_mutable_get_physical_layouts();
  public:
  void unsafe_arena_set_allocated_get_physical_layouts(
      ::zmk::keymap::PhysicalLayouts* get_physical_layouts);
  ::zmk::keymap::PhysicalLayouts* unsafe_arena_release_get_physical_layouts();

  // .zmk.keymap.SetActivePhysicalLayoutResponse set_active_physical_layout = 7;
  bool has_set_active_physical_layout() const;
  private:
  bool _internal_has_set_active_physical_layout() const;
  public:
  void clear_set_active_physical_layout();
  const ::zmk::keymap::SetActivePhysicalLayoutResponse& set_active_physical_layout() const;
  PROTOBUF_NODISCARD ::zmk::keymap::SetActivePhysicalLayoutResponse* release_set_active_physical_layout();
  ::zmk::keymap::SetActivePhysicalLayoutResponse* mutable_set_active_physical_layout();
  void set_allocated_set_active_physical_layout(::zmk::keymap::SetActivePhysicalLayoutResponse* set_active_physical_layout);
  private:
  const ::zmk::keymap::SetActivePhysicalLayoutResponse& _internal_set_active_physical_layout() const;
  ::zmk::keymap::SetActivePhysicalLayoutResponse* _internal_mutable_set_active_physical_layout();
  public:
  void unsafe_arena_set_allocated_set_active_physical_layout(
      ::zmk::keymap::SetActivePhysicalLayoutResponse* set_active_physical_layout);
  ::zmk::keymap::SetActivePhysicalLayoutResponse* unsafe_arena_release_set_active_physical_layout();

  // .zmk.keymap.MoveLayerResponse move_layer = 8;
  bool has_move_layer() const;
  private:
  bool _internal_has_move_layer() const;
  public:
  void clear_move_layer();
  const ::zmk::keymap::MoveLayerResponse& move_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::MoveLayerResponse* release_move_layer();
  ::zmk::keymap::MoveLayerResponse* mutable_move_layer();
  void set_allocated_move_layer(::zmk::keymap::MoveLayerResponse* move_layer);
  private:
  const ::zmk::keymap::MoveLayerResponse& _internal_move_layer() const;
  ::zmk::keymap::MoveLayerResponse* _internal_mutable_move_layer();
  public:
  void unsafe_arena_set_allocated_move_layer(
      ::zmk::keymap::MoveLayerResponse* move_layer);
  ::zmk::keymap::MoveLayerResponse* unsafe_arena_release_move_layer();

  // .zmk.keymap.AddLayerResponse add_layer = 9;
  bool has_add_layer() const;
  private:
  bool _internal_has_add_layer() const;
  public:
  void clear_add_layer();
  const ::zmk::keymap::AddLayerResponse& add_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::AddLayerResponse* release_add_layer();
  ::zmk::keymap::AddLayerResponse* mutable_add_layer();
  void set_allocated_add_layer(::zmk::keymap::AddLayerResponse* add_layer);
  private:
  const ::zmk::keymap::AddLayerResponse& _internal_add_layer() const;
  ::zmk::keymap::AddLayerResponse* _internal_mutable_add_layer();
  public:
  void unsafe_arena_set_allocated_add_layer(
      ::zmk::keymap::AddLayerResponse* add_layer);
  ::zmk::keymap::AddLayerResponse* unsafe_arena_release_add_layer();

  // .zmk.keymap.RemoveLayerResponse remove_layer = 10;
  bool has_remove_layer() const;
  private:
  bool _internal_has_remove_layer() const;
  public:
  void clear_remove_layer();
  const ::zmk::keymap::RemoveLayerResponse& remove_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::RemoveLayerResponse* release_remove_layer();
  ::zmk::keymap::RemoveLayerResponse* mutable_remove_layer();
  void set_allocated_remove_layer(::zmk::keymap::RemoveLayerResponse* remove_layer);
  private:
  const ::zmk::keymap::RemoveLayerResponse& _internal_remove_layer() const;
  ::zmk::keymap::RemoveLayerResponse* _internal_mutable_remove_layer();
  public:
  void unsafe_arena_set_allocated_remove_layer(
      ::zmk::keymap::RemoveLayerResponse* remove_layer);
  ::zmk::keymap::RemoveLayerResponse* unsafe_arena_release_remove_layer();

  // .zmk.keymap.RestoreLayerResponse restore_layer = 11;
  bool has_restore_layer() const;
  private:
  bool _internal_has_restore_layer() const;
  public:
  void clear_restore_layer();
  const ::zmk::keymap::RestoreLayerResponse& restore_layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::RestoreLayerResponse* release_restore_layer();
  ::zmk::keymap::RestoreLayerResponse* mutable_restore_layer();
  void set_allocated_restore_layer(::zmk::keymap::RestoreLayerResponse* restore_layer);
  private:
  const ::zmk::keymap::RestoreLayerResponse& _internal_restore_layer() const;
  ::zmk::keymap::RestoreLayerResponse* _internal_mutable_restore_layer();
  public:
  void unsafe_arena_set_allocated_restore_layer(
      ::zmk::keymap::RestoreLayerResponse* restore_layer);
  ::zmk::keymap::RestoreLayerResponse* unsafe_arena_release_restore_layer();

  // .zmk.keymap.SetLayerPropsResponse set_layer_props = 12;
  bool has_set_layer_props() const;
  private:
  bool _internal_has_set_layer_props() const;
  public:
  void clear_set_layer_props();
  ::zmk::keymap::SetLayerPropsResponse set_layer_props() const;
  void set_set_layer_props(::zmk::keymap::SetLayerPropsResponse value);
  private:
  ::zmk::keymap::SetLayerPropsResponse _internal_set_layer_props() const;
  void _internal_set_set_layer_props(::zmk::keymap::SetLayerPropsResponse value);
  public:

  void clear_response_type();
  ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.Response)
 private:
  class _Internal;
  void set_has_get_keymap();
  void set_has_set_layer_binding();
  void set_has_check_unsaved_changes();
  void set_has_save_changes();
  void set_has_discard_changes();
  void set_has_get_physical_layouts();
  void set_has_set_active_physical_layout();
  void set_has_move_layer();
  void set_has_add_layer();
  void set_has_remove_layer();
  void set_has_restore_layer();
  void set_has_set_layer_props();

  inline bool has_response_type() const;
  inline void clear_has_response_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResponseTypeUnion {
      constexpr ResponseTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::Keymap* get_keymap_;
      int set_layer_binding_;
      bool check_unsaved_changes_;
      ::zmk::keymap::SaveChangesResponse* save_changes_;
      bool discard_changes_;
      ::zmk::keymap::PhysicalLayouts* get_physical_layouts_;
      ::zmk::keymap::SetActivePhysicalLayoutResponse* set_active_physical_layout_;
      ::zmk::keymap::MoveLayerResponse* move_layer_;
      ::zmk::keymap::AddLayerResponse* add_layer_;
      ::zmk::keymap::RemoveLayerResponse* remove_layer_;
      ::zmk::keymap::RestoreLayerResponse* restore_layer_;
      int set_layer_props_;
    } response_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class Notification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.Notification) */ {
 public:
  inline Notification() : Notification(nullptr) {}
  ~Notification() override;
  explicit PROTOBUF_CONSTEXPR Notification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Notification(const Notification& from);
  Notification(Notification&& from) noexcept
    : Notification() {
    *this = ::std::move(from);
  }

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }
  inline Notification& operator=(Notification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Notification& default_instance() {
    return *internal_default_instance();
  }
  enum NotificationTypeCase {
    kUnsavedChangesStatusChanged = 1,
    NOTIFICATION_TYPE_NOT_SET = 0,
  };

  static inline const Notification* internal_default_instance() {
    return reinterpret_cast<const Notification*>(
               &_Notification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Notification& a, Notification& b) {
    a.Swap(&b);
  }
  inline void Swap(Notification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Notification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Notification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Notification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Notification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Notification& from) {
    Notification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Notification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.Notification";
  }
  protected:
  explicit Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUnsavedChangesStatusChangedFieldNumber = 1,
  };
  // bool unsaved_changes_status_changed = 1;
  bool has_unsaved_changes_status_changed() const;
  private:
  bool _internal_has_unsaved_changes_status_changed() const;
  public:
  void clear_unsaved_changes_status_changed();
  bool unsaved_changes_status_changed() const;
  void set_unsaved_changes_status_changed(bool value);
  private:
  bool _internal_unsaved_changes_status_changed() const;
  void _internal_set_unsaved_changes_status_changed(bool value);
  public:

  void clear_notification_type();
  NotificationTypeCase notification_type_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.Notification)
 private:
  class _Internal;
  void set_has_unsaved_changes_status_changed();

  inline bool has_notification_type() const;
  inline void clear_has_notification_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union NotificationTypeUnion {
      constexpr NotificationTypeUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool unsaved_changes_status_changed_;
    } notification_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class SaveChangesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.SaveChangesResponse) */ {
 public:
  inline SaveChangesResponse() : SaveChangesResponse(nullptr) {}
  ~SaveChangesResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveChangesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveChangesResponse(const SaveChangesResponse& from);
  SaveChangesResponse(SaveChangesResponse&& from) noexcept
    : SaveChangesResponse() {
    *this = ::std::move(from);
  }

  inline SaveChangesResponse& operator=(const SaveChangesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveChangesResponse& operator=(SaveChangesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveChangesResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const SaveChangesResponse* internal_default_instance() {
    return reinterpret_cast<const SaveChangesResponse*>(
               &_SaveChangesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SaveChangesResponse& a, SaveChangesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveChangesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveChangesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveChangesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveChangesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveChangesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SaveChangesResponse& from) {
    SaveChangesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveChangesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.SaveChangesResponse";
  }
  protected:
  explicit SaveChangesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // bool ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // .zmk.keymap.SaveChangesErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::SaveChangesErrorCode err() const;
  void set_err(::zmk::keymap::SaveChangesErrorCode value);
  private:
  ::zmk::keymap::SaveChangesErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::SaveChangesErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.SaveChangesResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      bool ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class SetActivePhysicalLayoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.SetActivePhysicalLayoutResponse) */ {
 public:
  inline SetActivePhysicalLayoutResponse() : SetActivePhysicalLayoutResponse(nullptr) {}
  ~SetActivePhysicalLayoutResponse() override;
  explicit PROTOBUF_CONSTEXPR SetActivePhysicalLayoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetActivePhysicalLayoutResponse(const SetActivePhysicalLayoutResponse& from);
  SetActivePhysicalLayoutResponse(SetActivePhysicalLayoutResponse&& from) noexcept
    : SetActivePhysicalLayoutResponse() {
    *this = ::std::move(from);
  }

  inline SetActivePhysicalLayoutResponse& operator=(const SetActivePhysicalLayoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetActivePhysicalLayoutResponse& operator=(SetActivePhysicalLayoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetActivePhysicalLayoutResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const SetActivePhysicalLayoutResponse* internal_default_instance() {
    return reinterpret_cast<const SetActivePhysicalLayoutResponse*>(
               &_SetActivePhysicalLayoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SetActivePhysicalLayoutResponse& a, SetActivePhysicalLayoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetActivePhysicalLayoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetActivePhysicalLayoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetActivePhysicalLayoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetActivePhysicalLayoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetActivePhysicalLayoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetActivePhysicalLayoutResponse& from) {
    SetActivePhysicalLayoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetActivePhysicalLayoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.SetActivePhysicalLayoutResponse";
  }
  protected:
  explicit SetActivePhysicalLayoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .zmk.keymap.Keymap ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::zmk::keymap::Keymap& ok() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Keymap* release_ok();
  ::zmk::keymap::Keymap* mutable_ok();
  void set_allocated_ok(::zmk::keymap::Keymap* ok);
  private:
  const ::zmk::keymap::Keymap& _internal_ok() const;
  ::zmk::keymap::Keymap* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::zmk::keymap::Keymap* ok);
  ::zmk::keymap::Keymap* unsafe_arena_release_ok();

  // .zmk.keymap.SetActivePhysicalLayoutErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::SetActivePhysicalLayoutErrorCode err() const;
  void set_err(::zmk::keymap::SetActivePhysicalLayoutErrorCode value);
  private:
  ::zmk::keymap::SetActivePhysicalLayoutErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::SetActivePhysicalLayoutErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.SetActivePhysicalLayoutResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::Keymap* ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class MoveLayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.MoveLayerResponse) */ {
 public:
  inline MoveLayerResponse() : MoveLayerResponse(nullptr) {}
  ~MoveLayerResponse() override;
  explicit PROTOBUF_CONSTEXPR MoveLayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveLayerResponse(const MoveLayerResponse& from);
  MoveLayerResponse(MoveLayerResponse&& from) noexcept
    : MoveLayerResponse() {
    *this = ::std::move(from);
  }

  inline MoveLayerResponse& operator=(const MoveLayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveLayerResponse& operator=(MoveLayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveLayerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const MoveLayerResponse* internal_default_instance() {
    return reinterpret_cast<const MoveLayerResponse*>(
               &_MoveLayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MoveLayerResponse& a, MoveLayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveLayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveLayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveLayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveLayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveLayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveLayerResponse& from) {
    MoveLayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveLayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.MoveLayerResponse";
  }
  protected:
  explicit MoveLayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .zmk.keymap.Keymap ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::zmk::keymap::Keymap& ok() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Keymap* release_ok();
  ::zmk::keymap::Keymap* mutable_ok();
  void set_allocated_ok(::zmk::keymap::Keymap* ok);
  private:
  const ::zmk::keymap::Keymap& _internal_ok() const;
  ::zmk::keymap::Keymap* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::zmk::keymap::Keymap* ok);
  ::zmk::keymap::Keymap* unsafe_arena_release_ok();

  // .zmk.keymap.MoveLayerErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::MoveLayerErrorCode err() const;
  void set_err(::zmk::keymap::MoveLayerErrorCode value);
  private:
  ::zmk::keymap::MoveLayerErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::MoveLayerErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.MoveLayerResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::Keymap* ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class AddLayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.AddLayerResponse) */ {
 public:
  inline AddLayerResponse() : AddLayerResponse(nullptr) {}
  ~AddLayerResponse() override;
  explicit PROTOBUF_CONSTEXPR AddLayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLayerResponse(const AddLayerResponse& from);
  AddLayerResponse(AddLayerResponse&& from) noexcept
    : AddLayerResponse() {
    *this = ::std::move(from);
  }

  inline AddLayerResponse& operator=(const AddLayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLayerResponse& operator=(AddLayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLayerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const AddLayerResponse* internal_default_instance() {
    return reinterpret_cast<const AddLayerResponse*>(
               &_AddLayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AddLayerResponse& a, AddLayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddLayerResponse& from) {
    AddLayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.AddLayerResponse";
  }
  protected:
  explicit AddLayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .zmk.keymap.AddLayerResponseDetails ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::zmk::keymap::AddLayerResponseDetails& ok() const;
  PROTOBUF_NODISCARD ::zmk::keymap::AddLayerResponseDetails* release_ok();
  ::zmk::keymap::AddLayerResponseDetails* mutable_ok();
  void set_allocated_ok(::zmk::keymap::AddLayerResponseDetails* ok);
  private:
  const ::zmk::keymap::AddLayerResponseDetails& _internal_ok() const;
  ::zmk::keymap::AddLayerResponseDetails* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::zmk::keymap::AddLayerResponseDetails* ok);
  ::zmk::keymap::AddLayerResponseDetails* unsafe_arena_release_ok();

  // .zmk.keymap.AddLayerErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::AddLayerErrorCode err() const;
  void set_err(::zmk::keymap::AddLayerErrorCode value);
  private:
  ::zmk::keymap::AddLayerErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::AddLayerErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.AddLayerResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::AddLayerResponseDetails* ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class AddLayerResponseDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.AddLayerResponseDetails) */ {
 public:
  inline AddLayerResponseDetails() : AddLayerResponseDetails(nullptr) {}
  ~AddLayerResponseDetails() override;
  explicit PROTOBUF_CONSTEXPR AddLayerResponseDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLayerResponseDetails(const AddLayerResponseDetails& from);
  AddLayerResponseDetails(AddLayerResponseDetails&& from) noexcept
    : AddLayerResponseDetails() {
    *this = ::std::move(from);
  }

  inline AddLayerResponseDetails& operator=(const AddLayerResponseDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLayerResponseDetails& operator=(AddLayerResponseDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLayerResponseDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLayerResponseDetails* internal_default_instance() {
    return reinterpret_cast<const AddLayerResponseDetails*>(
               &_AddLayerResponseDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AddLayerResponseDetails& a, AddLayerResponseDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLayerResponseDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLayerResponseDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLayerResponseDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLayerResponseDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddLayerResponseDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddLayerResponseDetails& from) {
    AddLayerResponseDetails::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddLayerResponseDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.AddLayerResponseDetails";
  }
  protected:
  explicit AddLayerResponseDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 2,
    kIndexFieldNumber = 1,
  };
  // .zmk.keymap.Layer layer = 2;
  bool has_layer() const;
  private:
  bool _internal_has_layer() const;
  public:
  void clear_layer();
  const ::zmk::keymap::Layer& layer() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Layer* release_layer();
  ::zmk::keymap::Layer* mutable_layer();
  void set_allocated_layer(::zmk::keymap::Layer* layer);
  private:
  const ::zmk::keymap::Layer& _internal_layer() const;
  ::zmk::keymap::Layer* _internal_mutable_layer();
  public:
  void unsafe_arena_set_allocated_layer(
      ::zmk::keymap::Layer* layer);
  ::zmk::keymap::Layer* unsafe_arena_release_layer();

  // uint32 index = 1;
  void clear_index();
  uint32_t index() const;
  void set_index(uint32_t value);
  private:
  uint32_t _internal_index() const;
  void _internal_set_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.AddLayerResponseDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::zmk::keymap::Layer* layer_;
    uint32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class RemoveLayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.RemoveLayerResponse) */ {
 public:
  inline RemoveLayerResponse() : RemoveLayerResponse(nullptr) {}
  ~RemoveLayerResponse() override;
  explicit PROTOBUF_CONSTEXPR RemoveLayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveLayerResponse(const RemoveLayerResponse& from);
  RemoveLayerResponse(RemoveLayerResponse&& from) noexcept
    : RemoveLayerResponse() {
    *this = ::std::move(from);
  }

  inline RemoveLayerResponse& operator=(const RemoveLayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLayerResponse& operator=(RemoveLayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLayerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const RemoveLayerResponse* internal_default_instance() {
    return reinterpret_cast<const RemoveLayerResponse*>(
               &_RemoveLayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RemoveLayerResponse& a, RemoveLayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveLayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveLayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveLayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveLayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveLayerResponse& from) {
    RemoveLayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveLayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.RemoveLayerResponse";
  }
  protected:
  explicit RemoveLayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .zmk.keymap.RemoveLayerOk ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::zmk::keymap::RemoveLayerOk& ok() const;
  PROTOBUF_NODISCARD ::zmk::keymap::RemoveLayerOk* release_ok();
  ::zmk::keymap::RemoveLayerOk* mutable_ok();
  void set_allocated_ok(::zmk::keymap::RemoveLayerOk* ok);
  private:
  const ::zmk::keymap::RemoveLayerOk& _internal_ok() const;
  ::zmk::keymap::RemoveLayerOk* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::zmk::keymap::RemoveLayerOk* ok);
  ::zmk::keymap::RemoveLayerOk* unsafe_arena_release_ok();

  // .zmk.keymap.RemoveLayerErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::RemoveLayerErrorCode err() const;
  void set_err(::zmk::keymap::RemoveLayerErrorCode value);
  private:
  ::zmk::keymap::RemoveLayerErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::RemoveLayerErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.RemoveLayerResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::RemoveLayerOk* ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class RemoveLayerOk final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zmk.keymap.RemoveLayerOk) */ {
 public:
  inline RemoveLayerOk() : RemoveLayerOk(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RemoveLayerOk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveLayerOk(const RemoveLayerOk& from);
  RemoveLayerOk(RemoveLayerOk&& from) noexcept
    : RemoveLayerOk() {
    *this = ::std::move(from);
  }

  inline RemoveLayerOk& operator=(const RemoveLayerOk& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLayerOk& operator=(RemoveLayerOk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLayerOk& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveLayerOk* internal_default_instance() {
    return reinterpret_cast<const RemoveLayerOk*>(
               &_RemoveLayerOk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RemoveLayerOk& a, RemoveLayerOk& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveLayerOk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLayerOk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveLayerOk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveLayerOk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RemoveLayerOk& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RemoveLayerOk& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.RemoveLayerOk";
  }
  protected:
  explicit RemoveLayerOk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zmk.keymap.RemoveLayerOk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class RestoreLayerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.RestoreLayerResponse) */ {
 public:
  inline RestoreLayerResponse() : RestoreLayerResponse(nullptr) {}
  ~RestoreLayerResponse() override;
  explicit PROTOBUF_CONSTEXPR RestoreLayerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreLayerResponse(const RestoreLayerResponse& from);
  RestoreLayerResponse(RestoreLayerResponse&& from) noexcept
    : RestoreLayerResponse() {
    *this = ::std::move(from);
  }

  inline RestoreLayerResponse& operator=(const RestoreLayerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreLayerResponse& operator=(RestoreLayerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreLayerResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResultCase {
    kOk = 1,
    kErr = 2,
    RESULT_NOT_SET = 0,
  };

  static inline const RestoreLayerResponse* internal_default_instance() {
    return reinterpret_cast<const RestoreLayerResponse*>(
               &_RestoreLayerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RestoreLayerResponse& a, RestoreLayerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreLayerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreLayerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreLayerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreLayerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreLayerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreLayerResponse& from) {
    RestoreLayerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreLayerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.RestoreLayerResponse";
  }
  protected:
  explicit RestoreLayerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
    kErrFieldNumber = 2,
  };
  // .zmk.keymap.Layer ok = 1;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  const ::zmk::keymap::Layer& ok() const;
  PROTOBUF_NODISCARD ::zmk::keymap::Layer* release_ok();
  ::zmk::keymap::Layer* mutable_ok();
  void set_allocated_ok(::zmk::keymap::Layer* ok);
  private:
  const ::zmk::keymap::Layer& _internal_ok() const;
  ::zmk::keymap::Layer* _internal_mutable_ok();
  public:
  void unsafe_arena_set_allocated_ok(
      ::zmk::keymap::Layer* ok);
  ::zmk::keymap::Layer* unsafe_arena_release_ok();

  // .zmk.keymap.RestoreLayerErrorCode err = 2;
  bool has_err() const;
  private:
  bool _internal_has_err() const;
  public:
  void clear_err();
  ::zmk::keymap::RestoreLayerErrorCode err() const;
  void set_err(::zmk::keymap::RestoreLayerErrorCode value);
  private:
  ::zmk::keymap::RestoreLayerErrorCode _internal_err() const;
  void _internal_set_err(::zmk::keymap::RestoreLayerErrorCode value);
  public:

  void clear_result();
  ResultCase result_case() const;
  // @@protoc_insertion_point(class_scope:zmk.keymap.RestoreLayerResponse)
 private:
  class _Internal;
  void set_has_ok();
  void set_has_err();

  inline bool has_result() const;
  inline void clear_has_result();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ResultUnion {
      constexpr ResultUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::zmk::keymap::Layer* ok_;
      int err_;
    } result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class SetLayerBindingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.SetLayerBindingRequest) */ {
 public:
  inline SetLayerBindingRequest() : SetLayerBindingRequest(nullptr) {}
  ~SetLayerBindingRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLayerBindingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLayerBindingRequest(const SetLayerBindingRequest& from);
  SetLayerBindingRequest(SetLayerBindingRequest&& from) noexcept
    : SetLayerBindingRequest() {
    *this = ::std::move(from);
  }

  inline SetLayerBindingRequest& operator=(const SetLayerBindingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLayerBindingRequest& operator=(SetLayerBindingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLayerBindingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLayerBindingRequest* internal_default_instance() {
    return reinterpret_cast<const SetLayerBindingRequest*>(
               &_SetLayerBindingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetLayerBindingRequest& a, SetLayerBindingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLayerBindingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLayerBindingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLayerBindingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLayerBindingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLayerBindingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLayerBindingRequest& from) {
    SetLayerBindingRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLayerBindingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.SetLayerBindingRequest";
  }
  protected:
  explicit SetLayerBindingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingFieldNumber = 3,
    kLayerIdFieldNumber = 1,
    kKeyPositionFieldNumber = 2,
  };
  // .zmk.keymap.BehaviorBinding binding = 3;
  bool has_binding() const;
  private:
  bool _internal_has_binding() const;
  public:
  void clear_binding();
  const ::zmk::keymap::BehaviorBinding& binding() const;
  PROTOBUF_NODISCARD ::zmk::keymap::BehaviorBinding* release_binding();
  ::zmk::keymap::BehaviorBinding* mutable_binding();
  void set_allocated_binding(::zmk::keymap::BehaviorBinding* binding);
  private:
  const ::zmk::keymap::BehaviorBinding& _internal_binding() const;
  ::zmk::keymap::BehaviorBinding* _internal_mutable_binding();
  public:
  void unsafe_arena_set_allocated_binding(
      ::zmk::keymap::BehaviorBinding* binding);
  ::zmk::keymap::BehaviorBinding* unsafe_arena_release_binding();

  // uint32 layer_id = 1;
  void clear_layer_id();
  uint32_t layer_id() const;
  void set_layer_id(uint32_t value);
  private:
  uint32_t _internal_layer_id() const;
  void _internal_set_layer_id(uint32_t value);
  public:

  // int32 key_position = 2;
  void clear_key_position();
  int32_t key_position() const;
  void set_key_position(int32_t value);
  private:
  int32_t _internal_key_position() const;
  void _internal_set_key_position(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.SetLayerBindingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::zmk::keymap::BehaviorBinding* binding_;
    uint32_t layer_id_;
    int32_t key_position_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class MoveLayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.MoveLayerRequest) */ {
 public:
  inline MoveLayerRequest() : MoveLayerRequest(nullptr) {}
  ~MoveLayerRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveLayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveLayerRequest(const MoveLayerRequest& from);
  MoveLayerRequest(MoveLayerRequest&& from) noexcept
    : MoveLayerRequest() {
    *this = ::std::move(from);
  }

  inline MoveLayerRequest& operator=(const MoveLayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveLayerRequest& operator=(MoveLayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveLayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveLayerRequest* internal_default_instance() {
    return reinterpret_cast<const MoveLayerRequest*>(
               &_MoveLayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MoveLayerRequest& a, MoveLayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveLayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveLayerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveLayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveLayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveLayerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MoveLayerRequest& from) {
    MoveLayerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveLayerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.MoveLayerRequest";
  }
  protected:
  explicit MoveLayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartIndexFieldNumber = 1,
    kDestIndexFieldNumber = 2,
  };
  // uint32 start_index = 1;
  void clear_start_index();
  uint32_t start_index() const;
  void set_start_index(uint32_t value);
  private:
  uint32_t _internal_start_index() const;
  void _internal_set_start_index(uint32_t value);
  public:

  // uint32 dest_index = 2;
  void clear_dest_index();
  uint32_t dest_index() const;
  void set_dest_index(uint32_t value);
  private:
  uint32_t _internal_dest_index() const;
  void _internal_set_dest_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.MoveLayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t start_index_;
    uint32_t dest_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class AddLayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:zmk.keymap.AddLayerRequest) */ {
 public:
  inline AddLayerRequest() : AddLayerRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AddLayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddLayerRequest(const AddLayerRequest& from);
  AddLayerRequest(AddLayerRequest&& from) noexcept
    : AddLayerRequest() {
    *this = ::std::move(from);
  }

  inline AddLayerRequest& operator=(const AddLayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddLayerRequest& operator=(AddLayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddLayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddLayerRequest* internal_default_instance() {
    return reinterpret_cast<const AddLayerRequest*>(
               &_AddLayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AddLayerRequest& a, AddLayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddLayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddLayerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddLayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddLayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AddLayerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AddLayerRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.AddLayerRequest";
  }
  protected:
  explicit AddLayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:zmk.keymap.AddLayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class RemoveLayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.RemoveLayerRequest) */ {
 public:
  inline RemoveLayerRequest() : RemoveLayerRequest(nullptr) {}
  ~RemoveLayerRequest() override;
  explicit PROTOBUF_CONSTEXPR RemoveLayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoveLayerRequest(const RemoveLayerRequest& from);
  RemoveLayerRequest(RemoveLayerRequest&& from) noexcept
    : RemoveLayerRequest() {
    *this = ::std::move(from);
  }

  inline RemoveLayerRequest& operator=(const RemoveLayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoveLayerRequest& operator=(RemoveLayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoveLayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoveLayerRequest* internal_default_instance() {
    return reinterpret_cast<const RemoveLayerRequest*>(
               &_RemoveLayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RemoveLayerRequest& a, RemoveLayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoveLayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoveLayerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RemoveLayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RemoveLayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoveLayerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RemoveLayerRequest& from) {
    RemoveLayerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveLayerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.RemoveLayerRequest";
  }
  protected:
  explicit RemoveLayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerIndexFieldNumber = 1,
  };
  // uint32 layer_index = 1;
  void clear_layer_index();
  uint32_t layer_index() const;
  void set_layer_index(uint32_t value);
  private:
  uint32_t _internal_layer_index() const;
  void _internal_set_layer_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.RemoveLayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t layer_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class RestoreLayerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.RestoreLayerRequest) */ {
 public:
  inline RestoreLayerRequest() : RestoreLayerRequest(nullptr) {}
  ~RestoreLayerRequest() override;
  explicit PROTOBUF_CONSTEXPR RestoreLayerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RestoreLayerRequest(const RestoreLayerRequest& from);
  RestoreLayerRequest(RestoreLayerRequest&& from) noexcept
    : RestoreLayerRequest() {
    *this = ::std::move(from);
  }

  inline RestoreLayerRequest& operator=(const RestoreLayerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RestoreLayerRequest& operator=(RestoreLayerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RestoreLayerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RestoreLayerRequest* internal_default_instance() {
    return reinterpret_cast<const RestoreLayerRequest*>(
               &_RestoreLayerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RestoreLayerRequest& a, RestoreLayerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RestoreLayerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RestoreLayerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RestoreLayerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RestoreLayerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RestoreLayerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RestoreLayerRequest& from) {
    RestoreLayerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreLayerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.RestoreLayerRequest";
  }
  protected:
  explicit RestoreLayerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerIdFieldNumber = 1,
    kAtIndexFieldNumber = 2,
  };
  // uint32 layer_id = 1;
  void clear_layer_id();
  uint32_t layer_id() const;
  void set_layer_id(uint32_t value);
  private:
  uint32_t _internal_layer_id() const;
  void _internal_set_layer_id(uint32_t value);
  public:

  // uint32 at_index = 2;
  void clear_at_index();
  uint32_t at_index() const;
  void set_at_index(uint32_t value);
  private:
  uint32_t _internal_at_index() const;
  void _internal_set_at_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.RestoreLayerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t layer_id_;
    uint32_t at_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class SetLayerPropsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.SetLayerPropsRequest) */ {
 public:
  inline SetLayerPropsRequest() : SetLayerPropsRequest(nullptr) {}
  ~SetLayerPropsRequest() override;
  explicit PROTOBUF_CONSTEXPR SetLayerPropsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetLayerPropsRequest(const SetLayerPropsRequest& from);
  SetLayerPropsRequest(SetLayerPropsRequest&& from) noexcept
    : SetLayerPropsRequest() {
    *this = ::std::move(from);
  }

  inline SetLayerPropsRequest& operator=(const SetLayerPropsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetLayerPropsRequest& operator=(SetLayerPropsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetLayerPropsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetLayerPropsRequest* internal_default_instance() {
    return reinterpret_cast<const SetLayerPropsRequest*>(
               &_SetLayerPropsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(SetLayerPropsRequest& a, SetLayerPropsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetLayerPropsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetLayerPropsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetLayerPropsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetLayerPropsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetLayerPropsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetLayerPropsRequest& from) {
    SetLayerPropsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetLayerPropsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.SetLayerPropsRequest";
  }
  protected:
  explicit SetLayerPropsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLayerIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 layer_id = 1;
  void clear_layer_id();
  uint32_t layer_id() const;
  void set_layer_id(uint32_t value);
  private:
  uint32_t _internal_layer_id() const;
  void _internal_set_layer_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.SetLayerPropsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t layer_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class Keymap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.Keymap) */ {
 public:
  inline Keymap() : Keymap(nullptr) {}
  ~Keymap() override;
  explicit PROTOBUF_CONSTEXPR Keymap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Keymap(const Keymap& from);
  Keymap(Keymap&& from) noexcept
    : Keymap() {
    *this = ::std::move(from);
  }

  inline Keymap& operator=(const Keymap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Keymap& operator=(Keymap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Keymap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Keymap* internal_default_instance() {
    return reinterpret_cast<const Keymap*>(
               &_Keymap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Keymap& a, Keymap& b) {
    a.Swap(&b);
  }
  inline void Swap(Keymap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Keymap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Keymap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Keymap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Keymap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Keymap& from) {
    Keymap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Keymap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.Keymap";
  }
  protected:
  explicit Keymap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 1,
    kAvailableLayersFieldNumber = 2,
    kMaxLayerNameLengthFieldNumber = 3,
  };
  // repeated .zmk.keymap.Layer layers = 1;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  ::zmk::keymap::Layer* mutable_layers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::Layer >*
      mutable_layers();
  private:
  const ::zmk::keymap::Layer& _internal_layers(int index) const;
  ::zmk::keymap::Layer* _internal_add_layers();
  public:
  const ::zmk::keymap::Layer& layers(int index) const;
  ::zmk::keymap::Layer* add_layers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::Layer >&
      layers() const;

  // uint32 available_layers = 2;
  void clear_available_layers();
  uint32_t available_layers() const;
  void set_available_layers(uint32_t value);
  private:
  uint32_t _internal_available_layers() const;
  void _internal_set_available_layers(uint32_t value);
  public:

  // uint32 max_layer_name_length = 3;
  void clear_max_layer_name_length();
  uint32_t max_layer_name_length() const;
  void set_max_layer_name_length(uint32_t value);
  private:
  uint32_t _internal_max_layer_name_length() const;
  void _internal_set_max_layer_name_length(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.Keymap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::Layer > layers_;
    uint32_t available_layers_;
    uint32_t max_layer_name_length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class Layer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.Layer) */ {
 public:
  inline Layer() : Layer(nullptr) {}
  ~Layer() override;
  explicit PROTOBUF_CONSTEXPR Layer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layer(const Layer& from);
  Layer(Layer&& from) noexcept
    : Layer() {
    *this = ::std::move(from);
  }

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layer& operator=(Layer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layer* internal_default_instance() {
    return reinterpret_cast<const Layer*>(
               &_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Layer& a, Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Layer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Layer& from) {
    Layer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.Layer";
  }
  protected:
  explicit Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBindingsFieldNumber = 3,
    kNameFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .zmk.keymap.BehaviorBinding bindings = 3;
  int bindings_size() const;
  private:
  int _internal_bindings_size() const;
  public:
  void clear_bindings();
  ::zmk::keymap::BehaviorBinding* mutable_bindings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::BehaviorBinding >*
      mutable_bindings();
  private:
  const ::zmk::keymap::BehaviorBinding& _internal_bindings(int index) const;
  ::zmk::keymap::BehaviorBinding* _internal_add_bindings();
  public:
  const ::zmk::keymap::BehaviorBinding& bindings(int index) const;
  ::zmk::keymap::BehaviorBinding* add_bindings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::BehaviorBinding >&
      bindings() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::BehaviorBinding > bindings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    uint32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class BehaviorBinding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.BehaviorBinding) */ {
 public:
  inline BehaviorBinding() : BehaviorBinding(nullptr) {}
  ~BehaviorBinding() override;
  explicit PROTOBUF_CONSTEXPR BehaviorBinding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BehaviorBinding(const BehaviorBinding& from);
  BehaviorBinding(BehaviorBinding&& from) noexcept
    : BehaviorBinding() {
    *this = ::std::move(from);
  }

  inline BehaviorBinding& operator=(const BehaviorBinding& from) {
    CopyFrom(from);
    return *this;
  }
  inline BehaviorBinding& operator=(BehaviorBinding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BehaviorBinding& default_instance() {
    return *internal_default_instance();
  }
  static inline const BehaviorBinding* internal_default_instance() {
    return reinterpret_cast<const BehaviorBinding*>(
               &_BehaviorBinding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BehaviorBinding& a, BehaviorBinding& b) {
    a.Swap(&b);
  }
  inline void Swap(BehaviorBinding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BehaviorBinding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BehaviorBinding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BehaviorBinding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BehaviorBinding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BehaviorBinding& from) {
    BehaviorBinding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BehaviorBinding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.BehaviorBinding";
  }
  protected:
  explicit BehaviorBinding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBehaviorIdFieldNumber = 1,
    kParam1FieldNumber = 2,
    kParam2FieldNumber = 3,
  };
  // sint32 behavior_id = 1;
  void clear_behavior_id();
  int32_t behavior_id() const;
  void set_behavior_id(int32_t value);
  private:
  int32_t _internal_behavior_id() const;
  void _internal_set_behavior_id(int32_t value);
  public:

  // uint32 param1 = 2;
  void clear_param1();
  uint32_t param1() const;
  void set_param1(uint32_t value);
  private:
  uint32_t _internal_param1() const;
  void _internal_set_param1(uint32_t value);
  public:

  // uint32 param2 = 3;
  void clear_param2();
  uint32_t param2() const;
  void set_param2(uint32_t value);
  private:
  uint32_t _internal_param2() const;
  void _internal_set_param2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.BehaviorBinding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t behavior_id_;
    uint32_t param1_;
    uint32_t param2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class PhysicalLayouts final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.PhysicalLayouts) */ {
 public:
  inline PhysicalLayouts() : PhysicalLayouts(nullptr) {}
  ~PhysicalLayouts() override;
  explicit PROTOBUF_CONSTEXPR PhysicalLayouts(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicalLayouts(const PhysicalLayouts& from);
  PhysicalLayouts(PhysicalLayouts&& from) noexcept
    : PhysicalLayouts() {
    *this = ::std::move(from);
  }

  inline PhysicalLayouts& operator=(const PhysicalLayouts& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalLayouts& operator=(PhysicalLayouts&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicalLayouts& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicalLayouts* internal_default_instance() {
    return reinterpret_cast<const PhysicalLayouts*>(
               &_PhysicalLayouts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PhysicalLayouts& a, PhysicalLayouts& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalLayouts* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalLayouts* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhysicalLayouts* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhysicalLayouts>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicalLayouts& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhysicalLayouts& from) {
    PhysicalLayouts::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalLayouts* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.PhysicalLayouts";
  }
  protected:
  explicit PhysicalLayouts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayoutsFieldNumber = 2,
    kActiveLayoutIndexFieldNumber = 1,
  };
  // repeated .zmk.keymap.PhysicalLayout layouts = 2;
  int layouts_size() const;
  private:
  int _internal_layouts_size() const;
  public:
  void clear_layouts();
  ::zmk::keymap::PhysicalLayout* mutable_layouts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::PhysicalLayout >*
      mutable_layouts();
  private:
  const ::zmk::keymap::PhysicalLayout& _internal_layouts(int index) const;
  ::zmk::keymap::PhysicalLayout* _internal_add_layouts();
  public:
  const ::zmk::keymap::PhysicalLayout& layouts(int index) const;
  ::zmk::keymap::PhysicalLayout* add_layouts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::PhysicalLayout >&
      layouts() const;

  // uint32 active_layout_index = 1;
  void clear_active_layout_index();
  uint32_t active_layout_index() const;
  void set_active_layout_index(uint32_t value);
  private:
  uint32_t _internal_active_layout_index() const;
  void _internal_set_active_layout_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.PhysicalLayouts)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::PhysicalLayout > layouts_;
    uint32_t active_layout_index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class PhysicalLayout final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.PhysicalLayout) */ {
 public:
  inline PhysicalLayout() : PhysicalLayout(nullptr) {}
  ~PhysicalLayout() override;
  explicit PROTOBUF_CONSTEXPR PhysicalLayout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PhysicalLayout(const PhysicalLayout& from);
  PhysicalLayout(PhysicalLayout&& from) noexcept
    : PhysicalLayout() {
    *this = ::std::move(from);
  }

  inline PhysicalLayout& operator=(const PhysicalLayout& from) {
    CopyFrom(from);
    return *this;
  }
  inline PhysicalLayout& operator=(PhysicalLayout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PhysicalLayout& default_instance() {
    return *internal_default_instance();
  }
  static inline const PhysicalLayout* internal_default_instance() {
    return reinterpret_cast<const PhysicalLayout*>(
               &_PhysicalLayout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PhysicalLayout& a, PhysicalLayout& b) {
    a.Swap(&b);
  }
  inline void Swap(PhysicalLayout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PhysicalLayout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PhysicalLayout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PhysicalLayout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PhysicalLayout& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PhysicalLayout& from) {
    PhysicalLayout::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicalLayout* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.PhysicalLayout";
  }
  protected:
  explicit PhysicalLayout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .zmk.keymap.KeyPhysicalAttrs keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::zmk::keymap::KeyPhysicalAttrs* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::KeyPhysicalAttrs >*
      mutable_keys();
  private:
  const ::zmk::keymap::KeyPhysicalAttrs& _internal_keys(int index) const;
  ::zmk::keymap::KeyPhysicalAttrs* _internal_add_keys();
  public:
  const ::zmk::keymap::KeyPhysicalAttrs& keys(int index) const;
  ::zmk::keymap::KeyPhysicalAttrs* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::KeyPhysicalAttrs >&
      keys() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.PhysicalLayout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::KeyPhysicalAttrs > keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// -------------------------------------------------------------------

class KeyPhysicalAttrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:zmk.keymap.KeyPhysicalAttrs) */ {
 public:
  inline KeyPhysicalAttrs() : KeyPhysicalAttrs(nullptr) {}
  ~KeyPhysicalAttrs() override;
  explicit PROTOBUF_CONSTEXPR KeyPhysicalAttrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyPhysicalAttrs(const KeyPhysicalAttrs& from);
  KeyPhysicalAttrs(KeyPhysicalAttrs&& from) noexcept
    : KeyPhysicalAttrs() {
    *this = ::std::move(from);
  }

  inline KeyPhysicalAttrs& operator=(const KeyPhysicalAttrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyPhysicalAttrs& operator=(KeyPhysicalAttrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyPhysicalAttrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyPhysicalAttrs* internal_default_instance() {
    return reinterpret_cast<const KeyPhysicalAttrs*>(
               &_KeyPhysicalAttrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(KeyPhysicalAttrs& a, KeyPhysicalAttrs& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyPhysicalAttrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyPhysicalAttrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyPhysicalAttrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyPhysicalAttrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyPhysicalAttrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyPhysicalAttrs& from) {
    KeyPhysicalAttrs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyPhysicalAttrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "zmk.keymap.KeyPhysicalAttrs";
  }
  protected:
  explicit KeyPhysicalAttrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kXFieldNumber = 3,
    kYFieldNumber = 4,
    kRFieldNumber = 5,
    kRxFieldNumber = 6,
    kRyFieldNumber = 7,
  };
  // sint32 width = 1;
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // sint32 height = 2;
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // sint32 x = 3;
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // sint32 y = 4;
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // sint32 r = 5;
  void clear_r();
  int32_t r() const;
  void set_r(int32_t value);
  private:
  int32_t _internal_r() const;
  void _internal_set_r(int32_t value);
  public:

  // sint32 rx = 6;
  void clear_rx();
  int32_t rx() const;
  void set_rx(int32_t value);
  private:
  int32_t _internal_rx() const;
  void _internal_set_rx(int32_t value);
  public:

  // sint32 ry = 7;
  void clear_ry();
  int32_t ry() const;
  void set_ry(int32_t value);
  private:
  int32_t _internal_ry() const;
  void _internal_set_ry(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:zmk.keymap.KeyPhysicalAttrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t width_;
    int32_t height_;
    int32_t x_;
    int32_t y_;
    int32_t r_;
    int32_t rx_;
    int32_t ry_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_keymap_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Request

// bool get_keymap = 1;
inline bool Request::_internal_has_get_keymap() const {
  return request_type_case() == kGetKeymap;
}
inline bool Request::has_get_keymap() const {
  return _internal_has_get_keymap();
}
inline void Request::set_has_get_keymap() {
  _impl_._oneof_case_[0] = kGetKeymap;
}
inline void Request::clear_get_keymap() {
  if (_internal_has_get_keymap()) {
    _impl_.request_type_.get_keymap_ = false;
    clear_has_request_type();
  }
}
inline bool Request::_internal_get_keymap() const {
  if (_internal_has_get_keymap()) {
    return _impl_.request_type_.get_keymap_;
  }
  return false;
}
inline void Request::_internal_set_get_keymap(bool value) {
  if (!_internal_has_get_keymap()) {
    clear_request_type();
    set_has_get_keymap();
  }
  _impl_.request_type_.get_keymap_ = value;
}
inline bool Request::get_keymap() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.get_keymap)
  return _internal_get_keymap();
}
inline void Request::set_get_keymap(bool value) {
  _internal_set_get_keymap(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.get_keymap)
}

// .zmk.keymap.SetLayerBindingRequest set_layer_binding = 2;
inline bool Request::_internal_has_set_layer_binding() const {
  return request_type_case() == kSetLayerBinding;
}
inline bool Request::has_set_layer_binding() const {
  return _internal_has_set_layer_binding();
}
inline void Request::set_has_set_layer_binding() {
  _impl_._oneof_case_[0] = kSetLayerBinding;
}
inline void Request::clear_set_layer_binding() {
  if (_internal_has_set_layer_binding()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.set_layer_binding_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::SetLayerBindingRequest* Request::release_set_layer_binding() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.set_layer_binding)
  if (_internal_has_set_layer_binding()) {
    clear_has_request_type();
    ::zmk::keymap::SetLayerBindingRequest* temp = _impl_.request_type_.set_layer_binding_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.set_layer_binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::SetLayerBindingRequest& Request::_internal_set_layer_binding() const {
  return _internal_has_set_layer_binding()
      ? *_impl_.request_type_.set_layer_binding_
      : reinterpret_cast< ::zmk::keymap::SetLayerBindingRequest&>(::zmk::keymap::_SetLayerBindingRequest_default_instance_);
}
inline const ::zmk::keymap::SetLayerBindingRequest& Request::set_layer_binding() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.set_layer_binding)
  return _internal_set_layer_binding();
}
inline ::zmk::keymap::SetLayerBindingRequest* Request::unsafe_arena_release_set_layer_binding() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.set_layer_binding)
  if (_internal_has_set_layer_binding()) {
    clear_has_request_type();
    ::zmk::keymap::SetLayerBindingRequest* temp = _impl_.request_type_.set_layer_binding_;
    _impl_.request_type_.set_layer_binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_set_layer_binding(::zmk::keymap::SetLayerBindingRequest* set_layer_binding) {
  clear_request_type();
  if (set_layer_binding) {
    set_has_set_layer_binding();
    _impl_.request_type_.set_layer_binding_ = set_layer_binding;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.set_layer_binding)
}
inline ::zmk::keymap::SetLayerBindingRequest* Request::_internal_mutable_set_layer_binding() {
  if (!_internal_has_set_layer_binding()) {
    clear_request_type();
    set_has_set_layer_binding();
    _impl_.request_type_.set_layer_binding_ = CreateMaybeMessage< ::zmk::keymap::SetLayerBindingRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.set_layer_binding_;
}
inline ::zmk::keymap::SetLayerBindingRequest* Request::mutable_set_layer_binding() {
  ::zmk::keymap::SetLayerBindingRequest* _msg = _internal_mutable_set_layer_binding();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.set_layer_binding)
  return _msg;
}

// bool check_unsaved_changes = 3;
inline bool Request::_internal_has_check_unsaved_changes() const {
  return request_type_case() == kCheckUnsavedChanges;
}
inline bool Request::has_check_unsaved_changes() const {
  return _internal_has_check_unsaved_changes();
}
inline void Request::set_has_check_unsaved_changes() {
  _impl_._oneof_case_[0] = kCheckUnsavedChanges;
}
inline void Request::clear_check_unsaved_changes() {
  if (_internal_has_check_unsaved_changes()) {
    _impl_.request_type_.check_unsaved_changes_ = false;
    clear_has_request_type();
  }
}
inline bool Request::_internal_check_unsaved_changes() const {
  if (_internal_has_check_unsaved_changes()) {
    return _impl_.request_type_.check_unsaved_changes_;
  }
  return false;
}
inline void Request::_internal_set_check_unsaved_changes(bool value) {
  if (!_internal_has_check_unsaved_changes()) {
    clear_request_type();
    set_has_check_unsaved_changes();
  }
  _impl_.request_type_.check_unsaved_changes_ = value;
}
inline bool Request::check_unsaved_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.check_unsaved_changes)
  return _internal_check_unsaved_changes();
}
inline void Request::set_check_unsaved_changes(bool value) {
  _internal_set_check_unsaved_changes(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.check_unsaved_changes)
}

// bool save_changes = 4;
inline bool Request::_internal_has_save_changes() const {
  return request_type_case() == kSaveChanges;
}
inline bool Request::has_save_changes() const {
  return _internal_has_save_changes();
}
inline void Request::set_has_save_changes() {
  _impl_._oneof_case_[0] = kSaveChanges;
}
inline void Request::clear_save_changes() {
  if (_internal_has_save_changes()) {
    _impl_.request_type_.save_changes_ = false;
    clear_has_request_type();
  }
}
inline bool Request::_internal_save_changes() const {
  if (_internal_has_save_changes()) {
    return _impl_.request_type_.save_changes_;
  }
  return false;
}
inline void Request::_internal_set_save_changes(bool value) {
  if (!_internal_has_save_changes()) {
    clear_request_type();
    set_has_save_changes();
  }
  _impl_.request_type_.save_changes_ = value;
}
inline bool Request::save_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.save_changes)
  return _internal_save_changes();
}
inline void Request::set_save_changes(bool value) {
  _internal_set_save_changes(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.save_changes)
}

// bool discard_changes = 5;
inline bool Request::_internal_has_discard_changes() const {
  return request_type_case() == kDiscardChanges;
}
inline bool Request::has_discard_changes() const {
  return _internal_has_discard_changes();
}
inline void Request::set_has_discard_changes() {
  _impl_._oneof_case_[0] = kDiscardChanges;
}
inline void Request::clear_discard_changes() {
  if (_internal_has_discard_changes()) {
    _impl_.request_type_.discard_changes_ = false;
    clear_has_request_type();
  }
}
inline bool Request::_internal_discard_changes() const {
  if (_internal_has_discard_changes()) {
    return _impl_.request_type_.discard_changes_;
  }
  return false;
}
inline void Request::_internal_set_discard_changes(bool value) {
  if (!_internal_has_discard_changes()) {
    clear_request_type();
    set_has_discard_changes();
  }
  _impl_.request_type_.discard_changes_ = value;
}
inline bool Request::discard_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.discard_changes)
  return _internal_discard_changes();
}
inline void Request::set_discard_changes(bool value) {
  _internal_set_discard_changes(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.discard_changes)
}

// bool get_physical_layouts = 6;
inline bool Request::_internal_has_get_physical_layouts() const {
  return request_type_case() == kGetPhysicalLayouts;
}
inline bool Request::has_get_physical_layouts() const {
  return _internal_has_get_physical_layouts();
}
inline void Request::set_has_get_physical_layouts() {
  _impl_._oneof_case_[0] = kGetPhysicalLayouts;
}
inline void Request::clear_get_physical_layouts() {
  if (_internal_has_get_physical_layouts()) {
    _impl_.request_type_.get_physical_layouts_ = false;
    clear_has_request_type();
  }
}
inline bool Request::_internal_get_physical_layouts() const {
  if (_internal_has_get_physical_layouts()) {
    return _impl_.request_type_.get_physical_layouts_;
  }
  return false;
}
inline void Request::_internal_set_get_physical_layouts(bool value) {
  if (!_internal_has_get_physical_layouts()) {
    clear_request_type();
    set_has_get_physical_layouts();
  }
  _impl_.request_type_.get_physical_layouts_ = value;
}
inline bool Request::get_physical_layouts() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.get_physical_layouts)
  return _internal_get_physical_layouts();
}
inline void Request::set_get_physical_layouts(bool value) {
  _internal_set_get_physical_layouts(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.get_physical_layouts)
}

// uint32 set_active_physical_layout = 7;
inline bool Request::_internal_has_set_active_physical_layout() const {
  return request_type_case() == kSetActivePhysicalLayout;
}
inline bool Request::has_set_active_physical_layout() const {
  return _internal_has_set_active_physical_layout();
}
inline void Request::set_has_set_active_physical_layout() {
  _impl_._oneof_case_[0] = kSetActivePhysicalLayout;
}
inline void Request::clear_set_active_physical_layout() {
  if (_internal_has_set_active_physical_layout()) {
    _impl_.request_type_.set_active_physical_layout_ = 0u;
    clear_has_request_type();
  }
}
inline uint32_t Request::_internal_set_active_physical_layout() const {
  if (_internal_has_set_active_physical_layout()) {
    return _impl_.request_type_.set_active_physical_layout_;
  }
  return 0u;
}
inline void Request::_internal_set_set_active_physical_layout(uint32_t value) {
  if (!_internal_has_set_active_physical_layout()) {
    clear_request_type();
    set_has_set_active_physical_layout();
  }
  _impl_.request_type_.set_active_physical_layout_ = value;
}
inline uint32_t Request::set_active_physical_layout() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.set_active_physical_layout)
  return _internal_set_active_physical_layout();
}
inline void Request::set_set_active_physical_layout(uint32_t value) {
  _internal_set_set_active_physical_layout(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Request.set_active_physical_layout)
}

// .zmk.keymap.MoveLayerRequest move_layer = 8;
inline bool Request::_internal_has_move_layer() const {
  return request_type_case() == kMoveLayer;
}
inline bool Request::has_move_layer() const {
  return _internal_has_move_layer();
}
inline void Request::set_has_move_layer() {
  _impl_._oneof_case_[0] = kMoveLayer;
}
inline void Request::clear_move_layer() {
  if (_internal_has_move_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.move_layer_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::MoveLayerRequest* Request::release_move_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.move_layer)
  if (_internal_has_move_layer()) {
    clear_has_request_type();
    ::zmk::keymap::MoveLayerRequest* temp = _impl_.request_type_.move_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.move_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::MoveLayerRequest& Request::_internal_move_layer() const {
  return _internal_has_move_layer()
      ? *_impl_.request_type_.move_layer_
      : reinterpret_cast< ::zmk::keymap::MoveLayerRequest&>(::zmk::keymap::_MoveLayerRequest_default_instance_);
}
inline const ::zmk::keymap::MoveLayerRequest& Request::move_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.move_layer)
  return _internal_move_layer();
}
inline ::zmk::keymap::MoveLayerRequest* Request::unsafe_arena_release_move_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.move_layer)
  if (_internal_has_move_layer()) {
    clear_has_request_type();
    ::zmk::keymap::MoveLayerRequest* temp = _impl_.request_type_.move_layer_;
    _impl_.request_type_.move_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_move_layer(::zmk::keymap::MoveLayerRequest* move_layer) {
  clear_request_type();
  if (move_layer) {
    set_has_move_layer();
    _impl_.request_type_.move_layer_ = move_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.move_layer)
}
inline ::zmk::keymap::MoveLayerRequest* Request::_internal_mutable_move_layer() {
  if (!_internal_has_move_layer()) {
    clear_request_type();
    set_has_move_layer();
    _impl_.request_type_.move_layer_ = CreateMaybeMessage< ::zmk::keymap::MoveLayerRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.move_layer_;
}
inline ::zmk::keymap::MoveLayerRequest* Request::mutable_move_layer() {
  ::zmk::keymap::MoveLayerRequest* _msg = _internal_mutable_move_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.move_layer)
  return _msg;
}

// .zmk.keymap.AddLayerRequest add_layer = 9;
inline bool Request::_internal_has_add_layer() const {
  return request_type_case() == kAddLayer;
}
inline bool Request::has_add_layer() const {
  return _internal_has_add_layer();
}
inline void Request::set_has_add_layer() {
  _impl_._oneof_case_[0] = kAddLayer;
}
inline void Request::clear_add_layer() {
  if (_internal_has_add_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.add_layer_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::AddLayerRequest* Request::release_add_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.add_layer)
  if (_internal_has_add_layer()) {
    clear_has_request_type();
    ::zmk::keymap::AddLayerRequest* temp = _impl_.request_type_.add_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.add_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::AddLayerRequest& Request::_internal_add_layer() const {
  return _internal_has_add_layer()
      ? *_impl_.request_type_.add_layer_
      : reinterpret_cast< ::zmk::keymap::AddLayerRequest&>(::zmk::keymap::_AddLayerRequest_default_instance_);
}
inline const ::zmk::keymap::AddLayerRequest& Request::add_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.add_layer)
  return _internal_add_layer();
}
inline ::zmk::keymap::AddLayerRequest* Request::unsafe_arena_release_add_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.add_layer)
  if (_internal_has_add_layer()) {
    clear_has_request_type();
    ::zmk::keymap::AddLayerRequest* temp = _impl_.request_type_.add_layer_;
    _impl_.request_type_.add_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_add_layer(::zmk::keymap::AddLayerRequest* add_layer) {
  clear_request_type();
  if (add_layer) {
    set_has_add_layer();
    _impl_.request_type_.add_layer_ = add_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.add_layer)
}
inline ::zmk::keymap::AddLayerRequest* Request::_internal_mutable_add_layer() {
  if (!_internal_has_add_layer()) {
    clear_request_type();
    set_has_add_layer();
    _impl_.request_type_.add_layer_ = CreateMaybeMessage< ::zmk::keymap::AddLayerRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.add_layer_;
}
inline ::zmk::keymap::AddLayerRequest* Request::mutable_add_layer() {
  ::zmk::keymap::AddLayerRequest* _msg = _internal_mutable_add_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.add_layer)
  return _msg;
}

// .zmk.keymap.RemoveLayerRequest remove_layer = 10;
inline bool Request::_internal_has_remove_layer() const {
  return request_type_case() == kRemoveLayer;
}
inline bool Request::has_remove_layer() const {
  return _internal_has_remove_layer();
}
inline void Request::set_has_remove_layer() {
  _impl_._oneof_case_[0] = kRemoveLayer;
}
inline void Request::clear_remove_layer() {
  if (_internal_has_remove_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.remove_layer_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::RemoveLayerRequest* Request::release_remove_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.remove_layer)
  if (_internal_has_remove_layer()) {
    clear_has_request_type();
    ::zmk::keymap::RemoveLayerRequest* temp = _impl_.request_type_.remove_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.remove_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::RemoveLayerRequest& Request::_internal_remove_layer() const {
  return _internal_has_remove_layer()
      ? *_impl_.request_type_.remove_layer_
      : reinterpret_cast< ::zmk::keymap::RemoveLayerRequest&>(::zmk::keymap::_RemoveLayerRequest_default_instance_);
}
inline const ::zmk::keymap::RemoveLayerRequest& Request::remove_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.remove_layer)
  return _internal_remove_layer();
}
inline ::zmk::keymap::RemoveLayerRequest* Request::unsafe_arena_release_remove_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.remove_layer)
  if (_internal_has_remove_layer()) {
    clear_has_request_type();
    ::zmk::keymap::RemoveLayerRequest* temp = _impl_.request_type_.remove_layer_;
    _impl_.request_type_.remove_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_remove_layer(::zmk::keymap::RemoveLayerRequest* remove_layer) {
  clear_request_type();
  if (remove_layer) {
    set_has_remove_layer();
    _impl_.request_type_.remove_layer_ = remove_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.remove_layer)
}
inline ::zmk::keymap::RemoveLayerRequest* Request::_internal_mutable_remove_layer() {
  if (!_internal_has_remove_layer()) {
    clear_request_type();
    set_has_remove_layer();
    _impl_.request_type_.remove_layer_ = CreateMaybeMessage< ::zmk::keymap::RemoveLayerRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.remove_layer_;
}
inline ::zmk::keymap::RemoveLayerRequest* Request::mutable_remove_layer() {
  ::zmk::keymap::RemoveLayerRequest* _msg = _internal_mutable_remove_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.remove_layer)
  return _msg;
}

// .zmk.keymap.RestoreLayerRequest restore_layer = 11;
inline bool Request::_internal_has_restore_layer() const {
  return request_type_case() == kRestoreLayer;
}
inline bool Request::has_restore_layer() const {
  return _internal_has_restore_layer();
}
inline void Request::set_has_restore_layer() {
  _impl_._oneof_case_[0] = kRestoreLayer;
}
inline void Request::clear_restore_layer() {
  if (_internal_has_restore_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.restore_layer_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::RestoreLayerRequest* Request::release_restore_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.restore_layer)
  if (_internal_has_restore_layer()) {
    clear_has_request_type();
    ::zmk::keymap::RestoreLayerRequest* temp = _impl_.request_type_.restore_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.restore_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::RestoreLayerRequest& Request::_internal_restore_layer() const {
  return _internal_has_restore_layer()
      ? *_impl_.request_type_.restore_layer_
      : reinterpret_cast< ::zmk::keymap::RestoreLayerRequest&>(::zmk::keymap::_RestoreLayerRequest_default_instance_);
}
inline const ::zmk::keymap::RestoreLayerRequest& Request::restore_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.restore_layer)
  return _internal_restore_layer();
}
inline ::zmk::keymap::RestoreLayerRequest* Request::unsafe_arena_release_restore_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.restore_layer)
  if (_internal_has_restore_layer()) {
    clear_has_request_type();
    ::zmk::keymap::RestoreLayerRequest* temp = _impl_.request_type_.restore_layer_;
    _impl_.request_type_.restore_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_restore_layer(::zmk::keymap::RestoreLayerRequest* restore_layer) {
  clear_request_type();
  if (restore_layer) {
    set_has_restore_layer();
    _impl_.request_type_.restore_layer_ = restore_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.restore_layer)
}
inline ::zmk::keymap::RestoreLayerRequest* Request::_internal_mutable_restore_layer() {
  if (!_internal_has_restore_layer()) {
    clear_request_type();
    set_has_restore_layer();
    _impl_.request_type_.restore_layer_ = CreateMaybeMessage< ::zmk::keymap::RestoreLayerRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.restore_layer_;
}
inline ::zmk::keymap::RestoreLayerRequest* Request::mutable_restore_layer() {
  ::zmk::keymap::RestoreLayerRequest* _msg = _internal_mutable_restore_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.restore_layer)
  return _msg;
}

// .zmk.keymap.SetLayerPropsRequest set_layer_props = 12;
inline bool Request::_internal_has_set_layer_props() const {
  return request_type_case() == kSetLayerProps;
}
inline bool Request::has_set_layer_props() const {
  return _internal_has_set_layer_props();
}
inline void Request::set_has_set_layer_props() {
  _impl_._oneof_case_[0] = kSetLayerProps;
}
inline void Request::clear_set_layer_props() {
  if (_internal_has_set_layer_props()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.request_type_.set_layer_props_;
    }
    clear_has_request_type();
  }
}
inline ::zmk::keymap::SetLayerPropsRequest* Request::release_set_layer_props() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Request.set_layer_props)
  if (_internal_has_set_layer_props()) {
    clear_has_request_type();
    ::zmk::keymap::SetLayerPropsRequest* temp = _impl_.request_type_.set_layer_props_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.request_type_.set_layer_props_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::SetLayerPropsRequest& Request::_internal_set_layer_props() const {
  return _internal_has_set_layer_props()
      ? *_impl_.request_type_.set_layer_props_
      : reinterpret_cast< ::zmk::keymap::SetLayerPropsRequest&>(::zmk::keymap::_SetLayerPropsRequest_default_instance_);
}
inline const ::zmk::keymap::SetLayerPropsRequest& Request::set_layer_props() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Request.set_layer_props)
  return _internal_set_layer_props();
}
inline ::zmk::keymap::SetLayerPropsRequest* Request::unsafe_arena_release_set_layer_props() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Request.set_layer_props)
  if (_internal_has_set_layer_props()) {
    clear_has_request_type();
    ::zmk::keymap::SetLayerPropsRequest* temp = _impl_.request_type_.set_layer_props_;
    _impl_.request_type_.set_layer_props_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Request::unsafe_arena_set_allocated_set_layer_props(::zmk::keymap::SetLayerPropsRequest* set_layer_props) {
  clear_request_type();
  if (set_layer_props) {
    set_has_set_layer_props();
    _impl_.request_type_.set_layer_props_ = set_layer_props;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Request.set_layer_props)
}
inline ::zmk::keymap::SetLayerPropsRequest* Request::_internal_mutable_set_layer_props() {
  if (!_internal_has_set_layer_props()) {
    clear_request_type();
    set_has_set_layer_props();
    _impl_.request_type_.set_layer_props_ = CreateMaybeMessage< ::zmk::keymap::SetLayerPropsRequest >(GetArenaForAllocation());
  }
  return _impl_.request_type_.set_layer_props_;
}
inline ::zmk::keymap::SetLayerPropsRequest* Request::mutable_set_layer_props() {
  ::zmk::keymap::SetLayerPropsRequest* _msg = _internal_mutable_set_layer_props();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Request.set_layer_props)
  return _msg;
}

inline bool Request::has_request_type() const {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void Request::clear_has_request_type() {
  _impl_._oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline Request::RequestTypeCase Request::request_type_case() const {
  return Request::RequestTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// .zmk.keymap.Keymap get_keymap = 1;
inline bool Response::_internal_has_get_keymap() const {
  return response_type_case() == kGetKeymap;
}
inline bool Response::has_get_keymap() const {
  return _internal_has_get_keymap();
}
inline void Response::set_has_get_keymap() {
  _impl_._oneof_case_[0] = kGetKeymap;
}
inline void Response::clear_get_keymap() {
  if (_internal_has_get_keymap()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.get_keymap_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::Keymap* Response::release_get_keymap() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.get_keymap)
  if (_internal_has_get_keymap()) {
    clear_has_response_type();
    ::zmk::keymap::Keymap* temp = _impl_.response_type_.get_keymap_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.get_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Keymap& Response::_internal_get_keymap() const {
  return _internal_has_get_keymap()
      ? *_impl_.response_type_.get_keymap_
      : reinterpret_cast< ::zmk::keymap::Keymap&>(::zmk::keymap::_Keymap_default_instance_);
}
inline const ::zmk::keymap::Keymap& Response::get_keymap() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.get_keymap)
  return _internal_get_keymap();
}
inline ::zmk::keymap::Keymap* Response::unsafe_arena_release_get_keymap() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.get_keymap)
  if (_internal_has_get_keymap()) {
    clear_has_response_type();
    ::zmk::keymap::Keymap* temp = _impl_.response_type_.get_keymap_;
    _impl_.response_type_.get_keymap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_get_keymap(::zmk::keymap::Keymap* get_keymap) {
  clear_response_type();
  if (get_keymap) {
    set_has_get_keymap();
    _impl_.response_type_.get_keymap_ = get_keymap;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.get_keymap)
}
inline ::zmk::keymap::Keymap* Response::_internal_mutable_get_keymap() {
  if (!_internal_has_get_keymap()) {
    clear_response_type();
    set_has_get_keymap();
    _impl_.response_type_.get_keymap_ = CreateMaybeMessage< ::zmk::keymap::Keymap >(GetArenaForAllocation());
  }
  return _impl_.response_type_.get_keymap_;
}
inline ::zmk::keymap::Keymap* Response::mutable_get_keymap() {
  ::zmk::keymap::Keymap* _msg = _internal_mutable_get_keymap();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.get_keymap)
  return _msg;
}

// .zmk.keymap.SetLayerBindingResponse set_layer_binding = 2;
inline bool Response::_internal_has_set_layer_binding() const {
  return response_type_case() == kSetLayerBinding;
}
inline bool Response::has_set_layer_binding() const {
  return _internal_has_set_layer_binding();
}
inline void Response::set_has_set_layer_binding() {
  _impl_._oneof_case_[0] = kSetLayerBinding;
}
inline void Response::clear_set_layer_binding() {
  if (_internal_has_set_layer_binding()) {
    _impl_.response_type_.set_layer_binding_ = 0;
    clear_has_response_type();
  }
}
inline ::zmk::keymap::SetLayerBindingResponse Response::_internal_set_layer_binding() const {
  if (_internal_has_set_layer_binding()) {
    return static_cast< ::zmk::keymap::SetLayerBindingResponse >(_impl_.response_type_.set_layer_binding_);
  }
  return static_cast< ::zmk::keymap::SetLayerBindingResponse >(0);
}
inline ::zmk::keymap::SetLayerBindingResponse Response::set_layer_binding() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.set_layer_binding)
  return _internal_set_layer_binding();
}
inline void Response::_internal_set_set_layer_binding(::zmk::keymap::SetLayerBindingResponse value) {
  if (!_internal_has_set_layer_binding()) {
    clear_response_type();
    set_has_set_layer_binding();
  }
  _impl_.response_type_.set_layer_binding_ = value;
}
inline void Response::set_set_layer_binding(::zmk::keymap::SetLayerBindingResponse value) {
  _internal_set_set_layer_binding(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Response.set_layer_binding)
}

// bool check_unsaved_changes = 3;
inline bool Response::_internal_has_check_unsaved_changes() const {
  return response_type_case() == kCheckUnsavedChanges;
}
inline bool Response::has_check_unsaved_changes() const {
  return _internal_has_check_unsaved_changes();
}
inline void Response::set_has_check_unsaved_changes() {
  _impl_._oneof_case_[0] = kCheckUnsavedChanges;
}
inline void Response::clear_check_unsaved_changes() {
  if (_internal_has_check_unsaved_changes()) {
    _impl_.response_type_.check_unsaved_changes_ = false;
    clear_has_response_type();
  }
}
inline bool Response::_internal_check_unsaved_changes() const {
  if (_internal_has_check_unsaved_changes()) {
    return _impl_.response_type_.check_unsaved_changes_;
  }
  return false;
}
inline void Response::_internal_set_check_unsaved_changes(bool value) {
  if (!_internal_has_check_unsaved_changes()) {
    clear_response_type();
    set_has_check_unsaved_changes();
  }
  _impl_.response_type_.check_unsaved_changes_ = value;
}
inline bool Response::check_unsaved_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.check_unsaved_changes)
  return _internal_check_unsaved_changes();
}
inline void Response::set_check_unsaved_changes(bool value) {
  _internal_set_check_unsaved_changes(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Response.check_unsaved_changes)
}

// .zmk.keymap.SaveChangesResponse save_changes = 4;
inline bool Response::_internal_has_save_changes() const {
  return response_type_case() == kSaveChanges;
}
inline bool Response::has_save_changes() const {
  return _internal_has_save_changes();
}
inline void Response::set_has_save_changes() {
  _impl_._oneof_case_[0] = kSaveChanges;
}
inline void Response::clear_save_changes() {
  if (_internal_has_save_changes()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.save_changes_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::SaveChangesResponse* Response::release_save_changes() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.save_changes)
  if (_internal_has_save_changes()) {
    clear_has_response_type();
    ::zmk::keymap::SaveChangesResponse* temp = _impl_.response_type_.save_changes_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.save_changes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::SaveChangesResponse& Response::_internal_save_changes() const {
  return _internal_has_save_changes()
      ? *_impl_.response_type_.save_changes_
      : reinterpret_cast< ::zmk::keymap::SaveChangesResponse&>(::zmk::keymap::_SaveChangesResponse_default_instance_);
}
inline const ::zmk::keymap::SaveChangesResponse& Response::save_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.save_changes)
  return _internal_save_changes();
}
inline ::zmk::keymap::SaveChangesResponse* Response::unsafe_arena_release_save_changes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.save_changes)
  if (_internal_has_save_changes()) {
    clear_has_response_type();
    ::zmk::keymap::SaveChangesResponse* temp = _impl_.response_type_.save_changes_;
    _impl_.response_type_.save_changes_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_save_changes(::zmk::keymap::SaveChangesResponse* save_changes) {
  clear_response_type();
  if (save_changes) {
    set_has_save_changes();
    _impl_.response_type_.save_changes_ = save_changes;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.save_changes)
}
inline ::zmk::keymap::SaveChangesResponse* Response::_internal_mutable_save_changes() {
  if (!_internal_has_save_changes()) {
    clear_response_type();
    set_has_save_changes();
    _impl_.response_type_.save_changes_ = CreateMaybeMessage< ::zmk::keymap::SaveChangesResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.save_changes_;
}
inline ::zmk::keymap::SaveChangesResponse* Response::mutable_save_changes() {
  ::zmk::keymap::SaveChangesResponse* _msg = _internal_mutable_save_changes();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.save_changes)
  return _msg;
}

// bool discard_changes = 5;
inline bool Response::_internal_has_discard_changes() const {
  return response_type_case() == kDiscardChanges;
}
inline bool Response::has_discard_changes() const {
  return _internal_has_discard_changes();
}
inline void Response::set_has_discard_changes() {
  _impl_._oneof_case_[0] = kDiscardChanges;
}
inline void Response::clear_discard_changes() {
  if (_internal_has_discard_changes()) {
    _impl_.response_type_.discard_changes_ = false;
    clear_has_response_type();
  }
}
inline bool Response::_internal_discard_changes() const {
  if (_internal_has_discard_changes()) {
    return _impl_.response_type_.discard_changes_;
  }
  return false;
}
inline void Response::_internal_set_discard_changes(bool value) {
  if (!_internal_has_discard_changes()) {
    clear_response_type();
    set_has_discard_changes();
  }
  _impl_.response_type_.discard_changes_ = value;
}
inline bool Response::discard_changes() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.discard_changes)
  return _internal_discard_changes();
}
inline void Response::set_discard_changes(bool value) {
  _internal_set_discard_changes(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Response.discard_changes)
}

// .zmk.keymap.PhysicalLayouts get_physical_layouts = 6;
inline bool Response::_internal_has_get_physical_layouts() const {
  return response_type_case() == kGetPhysicalLayouts;
}
inline bool Response::has_get_physical_layouts() const {
  return _internal_has_get_physical_layouts();
}
inline void Response::set_has_get_physical_layouts() {
  _impl_._oneof_case_[0] = kGetPhysicalLayouts;
}
inline void Response::clear_get_physical_layouts() {
  if (_internal_has_get_physical_layouts()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.get_physical_layouts_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::PhysicalLayouts* Response::release_get_physical_layouts() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.get_physical_layouts)
  if (_internal_has_get_physical_layouts()) {
    clear_has_response_type();
    ::zmk::keymap::PhysicalLayouts* temp = _impl_.response_type_.get_physical_layouts_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.get_physical_layouts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::PhysicalLayouts& Response::_internal_get_physical_layouts() const {
  return _internal_has_get_physical_layouts()
      ? *_impl_.response_type_.get_physical_layouts_
      : reinterpret_cast< ::zmk::keymap::PhysicalLayouts&>(::zmk::keymap::_PhysicalLayouts_default_instance_);
}
inline const ::zmk::keymap::PhysicalLayouts& Response::get_physical_layouts() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.get_physical_layouts)
  return _internal_get_physical_layouts();
}
inline ::zmk::keymap::PhysicalLayouts* Response::unsafe_arena_release_get_physical_layouts() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.get_physical_layouts)
  if (_internal_has_get_physical_layouts()) {
    clear_has_response_type();
    ::zmk::keymap::PhysicalLayouts* temp = _impl_.response_type_.get_physical_layouts_;
    _impl_.response_type_.get_physical_layouts_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_get_physical_layouts(::zmk::keymap::PhysicalLayouts* get_physical_layouts) {
  clear_response_type();
  if (get_physical_layouts) {
    set_has_get_physical_layouts();
    _impl_.response_type_.get_physical_layouts_ = get_physical_layouts;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.get_physical_layouts)
}
inline ::zmk::keymap::PhysicalLayouts* Response::_internal_mutable_get_physical_layouts() {
  if (!_internal_has_get_physical_layouts()) {
    clear_response_type();
    set_has_get_physical_layouts();
    _impl_.response_type_.get_physical_layouts_ = CreateMaybeMessage< ::zmk::keymap::PhysicalLayouts >(GetArenaForAllocation());
  }
  return _impl_.response_type_.get_physical_layouts_;
}
inline ::zmk::keymap::PhysicalLayouts* Response::mutable_get_physical_layouts() {
  ::zmk::keymap::PhysicalLayouts* _msg = _internal_mutable_get_physical_layouts();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.get_physical_layouts)
  return _msg;
}

// .zmk.keymap.SetActivePhysicalLayoutResponse set_active_physical_layout = 7;
inline bool Response::_internal_has_set_active_physical_layout() const {
  return response_type_case() == kSetActivePhysicalLayout;
}
inline bool Response::has_set_active_physical_layout() const {
  return _internal_has_set_active_physical_layout();
}
inline void Response::set_has_set_active_physical_layout() {
  _impl_._oneof_case_[0] = kSetActivePhysicalLayout;
}
inline void Response::clear_set_active_physical_layout() {
  if (_internal_has_set_active_physical_layout()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.set_active_physical_layout_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::SetActivePhysicalLayoutResponse* Response::release_set_active_physical_layout() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.set_active_physical_layout)
  if (_internal_has_set_active_physical_layout()) {
    clear_has_response_type();
    ::zmk::keymap::SetActivePhysicalLayoutResponse* temp = _impl_.response_type_.set_active_physical_layout_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.set_active_physical_layout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::SetActivePhysicalLayoutResponse& Response::_internal_set_active_physical_layout() const {
  return _internal_has_set_active_physical_layout()
      ? *_impl_.response_type_.set_active_physical_layout_
      : reinterpret_cast< ::zmk::keymap::SetActivePhysicalLayoutResponse&>(::zmk::keymap::_SetActivePhysicalLayoutResponse_default_instance_);
}
inline const ::zmk::keymap::SetActivePhysicalLayoutResponse& Response::set_active_physical_layout() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.set_active_physical_layout)
  return _internal_set_active_physical_layout();
}
inline ::zmk::keymap::SetActivePhysicalLayoutResponse* Response::unsafe_arena_release_set_active_physical_layout() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.set_active_physical_layout)
  if (_internal_has_set_active_physical_layout()) {
    clear_has_response_type();
    ::zmk::keymap::SetActivePhysicalLayoutResponse* temp = _impl_.response_type_.set_active_physical_layout_;
    _impl_.response_type_.set_active_physical_layout_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_set_active_physical_layout(::zmk::keymap::SetActivePhysicalLayoutResponse* set_active_physical_layout) {
  clear_response_type();
  if (set_active_physical_layout) {
    set_has_set_active_physical_layout();
    _impl_.response_type_.set_active_physical_layout_ = set_active_physical_layout;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.set_active_physical_layout)
}
inline ::zmk::keymap::SetActivePhysicalLayoutResponse* Response::_internal_mutable_set_active_physical_layout() {
  if (!_internal_has_set_active_physical_layout()) {
    clear_response_type();
    set_has_set_active_physical_layout();
    _impl_.response_type_.set_active_physical_layout_ = CreateMaybeMessage< ::zmk::keymap::SetActivePhysicalLayoutResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.set_active_physical_layout_;
}
inline ::zmk::keymap::SetActivePhysicalLayoutResponse* Response::mutable_set_active_physical_layout() {
  ::zmk::keymap::SetActivePhysicalLayoutResponse* _msg = _internal_mutable_set_active_physical_layout();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.set_active_physical_layout)
  return _msg;
}

// .zmk.keymap.MoveLayerResponse move_layer = 8;
inline bool Response::_internal_has_move_layer() const {
  return response_type_case() == kMoveLayer;
}
inline bool Response::has_move_layer() const {
  return _internal_has_move_layer();
}
inline void Response::set_has_move_layer() {
  _impl_._oneof_case_[0] = kMoveLayer;
}
inline void Response::clear_move_layer() {
  if (_internal_has_move_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.move_layer_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::MoveLayerResponse* Response::release_move_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.move_layer)
  if (_internal_has_move_layer()) {
    clear_has_response_type();
    ::zmk::keymap::MoveLayerResponse* temp = _impl_.response_type_.move_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.move_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::MoveLayerResponse& Response::_internal_move_layer() const {
  return _internal_has_move_layer()
      ? *_impl_.response_type_.move_layer_
      : reinterpret_cast< ::zmk::keymap::MoveLayerResponse&>(::zmk::keymap::_MoveLayerResponse_default_instance_);
}
inline const ::zmk::keymap::MoveLayerResponse& Response::move_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.move_layer)
  return _internal_move_layer();
}
inline ::zmk::keymap::MoveLayerResponse* Response::unsafe_arena_release_move_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.move_layer)
  if (_internal_has_move_layer()) {
    clear_has_response_type();
    ::zmk::keymap::MoveLayerResponse* temp = _impl_.response_type_.move_layer_;
    _impl_.response_type_.move_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_move_layer(::zmk::keymap::MoveLayerResponse* move_layer) {
  clear_response_type();
  if (move_layer) {
    set_has_move_layer();
    _impl_.response_type_.move_layer_ = move_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.move_layer)
}
inline ::zmk::keymap::MoveLayerResponse* Response::_internal_mutable_move_layer() {
  if (!_internal_has_move_layer()) {
    clear_response_type();
    set_has_move_layer();
    _impl_.response_type_.move_layer_ = CreateMaybeMessage< ::zmk::keymap::MoveLayerResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.move_layer_;
}
inline ::zmk::keymap::MoveLayerResponse* Response::mutable_move_layer() {
  ::zmk::keymap::MoveLayerResponse* _msg = _internal_mutable_move_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.move_layer)
  return _msg;
}

// .zmk.keymap.AddLayerResponse add_layer = 9;
inline bool Response::_internal_has_add_layer() const {
  return response_type_case() == kAddLayer;
}
inline bool Response::has_add_layer() const {
  return _internal_has_add_layer();
}
inline void Response::set_has_add_layer() {
  _impl_._oneof_case_[0] = kAddLayer;
}
inline void Response::clear_add_layer() {
  if (_internal_has_add_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.add_layer_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::AddLayerResponse* Response::release_add_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.add_layer)
  if (_internal_has_add_layer()) {
    clear_has_response_type();
    ::zmk::keymap::AddLayerResponse* temp = _impl_.response_type_.add_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.add_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::AddLayerResponse& Response::_internal_add_layer() const {
  return _internal_has_add_layer()
      ? *_impl_.response_type_.add_layer_
      : reinterpret_cast< ::zmk::keymap::AddLayerResponse&>(::zmk::keymap::_AddLayerResponse_default_instance_);
}
inline const ::zmk::keymap::AddLayerResponse& Response::add_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.add_layer)
  return _internal_add_layer();
}
inline ::zmk::keymap::AddLayerResponse* Response::unsafe_arena_release_add_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.add_layer)
  if (_internal_has_add_layer()) {
    clear_has_response_type();
    ::zmk::keymap::AddLayerResponse* temp = _impl_.response_type_.add_layer_;
    _impl_.response_type_.add_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_add_layer(::zmk::keymap::AddLayerResponse* add_layer) {
  clear_response_type();
  if (add_layer) {
    set_has_add_layer();
    _impl_.response_type_.add_layer_ = add_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.add_layer)
}
inline ::zmk::keymap::AddLayerResponse* Response::_internal_mutable_add_layer() {
  if (!_internal_has_add_layer()) {
    clear_response_type();
    set_has_add_layer();
    _impl_.response_type_.add_layer_ = CreateMaybeMessage< ::zmk::keymap::AddLayerResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.add_layer_;
}
inline ::zmk::keymap::AddLayerResponse* Response::mutable_add_layer() {
  ::zmk::keymap::AddLayerResponse* _msg = _internal_mutable_add_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.add_layer)
  return _msg;
}

// .zmk.keymap.RemoveLayerResponse remove_layer = 10;
inline bool Response::_internal_has_remove_layer() const {
  return response_type_case() == kRemoveLayer;
}
inline bool Response::has_remove_layer() const {
  return _internal_has_remove_layer();
}
inline void Response::set_has_remove_layer() {
  _impl_._oneof_case_[0] = kRemoveLayer;
}
inline void Response::clear_remove_layer() {
  if (_internal_has_remove_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.remove_layer_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::RemoveLayerResponse* Response::release_remove_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.remove_layer)
  if (_internal_has_remove_layer()) {
    clear_has_response_type();
    ::zmk::keymap::RemoveLayerResponse* temp = _impl_.response_type_.remove_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.remove_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::RemoveLayerResponse& Response::_internal_remove_layer() const {
  return _internal_has_remove_layer()
      ? *_impl_.response_type_.remove_layer_
      : reinterpret_cast< ::zmk::keymap::RemoveLayerResponse&>(::zmk::keymap::_RemoveLayerResponse_default_instance_);
}
inline const ::zmk::keymap::RemoveLayerResponse& Response::remove_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.remove_layer)
  return _internal_remove_layer();
}
inline ::zmk::keymap::RemoveLayerResponse* Response::unsafe_arena_release_remove_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.remove_layer)
  if (_internal_has_remove_layer()) {
    clear_has_response_type();
    ::zmk::keymap::RemoveLayerResponse* temp = _impl_.response_type_.remove_layer_;
    _impl_.response_type_.remove_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_remove_layer(::zmk::keymap::RemoveLayerResponse* remove_layer) {
  clear_response_type();
  if (remove_layer) {
    set_has_remove_layer();
    _impl_.response_type_.remove_layer_ = remove_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.remove_layer)
}
inline ::zmk::keymap::RemoveLayerResponse* Response::_internal_mutable_remove_layer() {
  if (!_internal_has_remove_layer()) {
    clear_response_type();
    set_has_remove_layer();
    _impl_.response_type_.remove_layer_ = CreateMaybeMessage< ::zmk::keymap::RemoveLayerResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.remove_layer_;
}
inline ::zmk::keymap::RemoveLayerResponse* Response::mutable_remove_layer() {
  ::zmk::keymap::RemoveLayerResponse* _msg = _internal_mutable_remove_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.remove_layer)
  return _msg;
}

// .zmk.keymap.RestoreLayerResponse restore_layer = 11;
inline bool Response::_internal_has_restore_layer() const {
  return response_type_case() == kRestoreLayer;
}
inline bool Response::has_restore_layer() const {
  return _internal_has_restore_layer();
}
inline void Response::set_has_restore_layer() {
  _impl_._oneof_case_[0] = kRestoreLayer;
}
inline void Response::clear_restore_layer() {
  if (_internal_has_restore_layer()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.response_type_.restore_layer_;
    }
    clear_has_response_type();
  }
}
inline ::zmk::keymap::RestoreLayerResponse* Response::release_restore_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Response.restore_layer)
  if (_internal_has_restore_layer()) {
    clear_has_response_type();
    ::zmk::keymap::RestoreLayerResponse* temp = _impl_.response_type_.restore_layer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.response_type_.restore_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::RestoreLayerResponse& Response::_internal_restore_layer() const {
  return _internal_has_restore_layer()
      ? *_impl_.response_type_.restore_layer_
      : reinterpret_cast< ::zmk::keymap::RestoreLayerResponse&>(::zmk::keymap::_RestoreLayerResponse_default_instance_);
}
inline const ::zmk::keymap::RestoreLayerResponse& Response::restore_layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.restore_layer)
  return _internal_restore_layer();
}
inline ::zmk::keymap::RestoreLayerResponse* Response::unsafe_arena_release_restore_layer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.Response.restore_layer)
  if (_internal_has_restore_layer()) {
    clear_has_response_type();
    ::zmk::keymap::RestoreLayerResponse* temp = _impl_.response_type_.restore_layer_;
    _impl_.response_type_.restore_layer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Response::unsafe_arena_set_allocated_restore_layer(::zmk::keymap::RestoreLayerResponse* restore_layer) {
  clear_response_type();
  if (restore_layer) {
    set_has_restore_layer();
    _impl_.response_type_.restore_layer_ = restore_layer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.Response.restore_layer)
}
inline ::zmk::keymap::RestoreLayerResponse* Response::_internal_mutable_restore_layer() {
  if (!_internal_has_restore_layer()) {
    clear_response_type();
    set_has_restore_layer();
    _impl_.response_type_.restore_layer_ = CreateMaybeMessage< ::zmk::keymap::RestoreLayerResponse >(GetArenaForAllocation());
  }
  return _impl_.response_type_.restore_layer_;
}
inline ::zmk::keymap::RestoreLayerResponse* Response::mutable_restore_layer() {
  ::zmk::keymap::RestoreLayerResponse* _msg = _internal_mutable_restore_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Response.restore_layer)
  return _msg;
}

// .zmk.keymap.SetLayerPropsResponse set_layer_props = 12;
inline bool Response::_internal_has_set_layer_props() const {
  return response_type_case() == kSetLayerProps;
}
inline bool Response::has_set_layer_props() const {
  return _internal_has_set_layer_props();
}
inline void Response::set_has_set_layer_props() {
  _impl_._oneof_case_[0] = kSetLayerProps;
}
inline void Response::clear_set_layer_props() {
  if (_internal_has_set_layer_props()) {
    _impl_.response_type_.set_layer_props_ = 0;
    clear_has_response_type();
  }
}
inline ::zmk::keymap::SetLayerPropsResponse Response::_internal_set_layer_props() const {
  if (_internal_has_set_layer_props()) {
    return static_cast< ::zmk::keymap::SetLayerPropsResponse >(_impl_.response_type_.set_layer_props_);
  }
  return static_cast< ::zmk::keymap::SetLayerPropsResponse >(0);
}
inline ::zmk::keymap::SetLayerPropsResponse Response::set_layer_props() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Response.set_layer_props)
  return _internal_set_layer_props();
}
inline void Response::_internal_set_set_layer_props(::zmk::keymap::SetLayerPropsResponse value) {
  if (!_internal_has_set_layer_props()) {
    clear_response_type();
    set_has_set_layer_props();
  }
  _impl_.response_type_.set_layer_props_ = value;
}
inline void Response::set_set_layer_props(::zmk::keymap::SetLayerPropsResponse value) {
  _internal_set_set_layer_props(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Response.set_layer_props)
}

inline bool Response::has_response_type() const {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void Response::clear_has_response_type() {
  _impl_._oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline Response::ResponseTypeCase Response::response_type_case() const {
  return Response::ResponseTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Notification

// bool unsaved_changes_status_changed = 1;
inline bool Notification::_internal_has_unsaved_changes_status_changed() const {
  return notification_type_case() == kUnsavedChangesStatusChanged;
}
inline bool Notification::has_unsaved_changes_status_changed() const {
  return _internal_has_unsaved_changes_status_changed();
}
inline void Notification::set_has_unsaved_changes_status_changed() {
  _impl_._oneof_case_[0] = kUnsavedChangesStatusChanged;
}
inline void Notification::clear_unsaved_changes_status_changed() {
  if (_internal_has_unsaved_changes_status_changed()) {
    _impl_.notification_type_.unsaved_changes_status_changed_ = false;
    clear_has_notification_type();
  }
}
inline bool Notification::_internal_unsaved_changes_status_changed() const {
  if (_internal_has_unsaved_changes_status_changed()) {
    return _impl_.notification_type_.unsaved_changes_status_changed_;
  }
  return false;
}
inline void Notification::_internal_set_unsaved_changes_status_changed(bool value) {
  if (!_internal_has_unsaved_changes_status_changed()) {
    clear_notification_type();
    set_has_unsaved_changes_status_changed();
  }
  _impl_.notification_type_.unsaved_changes_status_changed_ = value;
}
inline bool Notification::unsaved_changes_status_changed() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Notification.unsaved_changes_status_changed)
  return _internal_unsaved_changes_status_changed();
}
inline void Notification::set_unsaved_changes_status_changed(bool value) {
  _internal_set_unsaved_changes_status_changed(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Notification.unsaved_changes_status_changed)
}

inline bool Notification::has_notification_type() const {
  return notification_type_case() != NOTIFICATION_TYPE_NOT_SET;
}
inline void Notification::clear_has_notification_type() {
  _impl_._oneof_case_[0] = NOTIFICATION_TYPE_NOT_SET;
}
inline Notification::NotificationTypeCase Notification::notification_type_case() const {
  return Notification::NotificationTypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SaveChangesResponse

// bool ok = 1;
inline bool SaveChangesResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool SaveChangesResponse::has_ok() const {
  return _internal_has_ok();
}
inline void SaveChangesResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void SaveChangesResponse::clear_ok() {
  if (_internal_has_ok()) {
    _impl_.result_.ok_ = false;
    clear_has_result();
  }
}
inline bool SaveChangesResponse::_internal_ok() const {
  if (_internal_has_ok()) {
    return _impl_.result_.ok_;
  }
  return false;
}
inline void SaveChangesResponse::_internal_set_ok(bool value) {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
  }
  _impl_.result_.ok_ = value;
}
inline bool SaveChangesResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SaveChangesResponse.ok)
  return _internal_ok();
}
inline void SaveChangesResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SaveChangesResponse.ok)
}

// .zmk.keymap.SaveChangesErrorCode err = 2;
inline bool SaveChangesResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool SaveChangesResponse::has_err() const {
  return _internal_has_err();
}
inline void SaveChangesResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void SaveChangesResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::SaveChangesErrorCode SaveChangesResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::SaveChangesErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::SaveChangesErrorCode >(0);
}
inline ::zmk::keymap::SaveChangesErrorCode SaveChangesResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SaveChangesResponse.err)
  return _internal_err();
}
inline void SaveChangesResponse::_internal_set_err(::zmk::keymap::SaveChangesErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void SaveChangesResponse::set_err(::zmk::keymap::SaveChangesErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SaveChangesResponse.err)
}

inline bool SaveChangesResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void SaveChangesResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline SaveChangesResponse::ResultCase SaveChangesResponse::result_case() const {
  return SaveChangesResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetActivePhysicalLayoutResponse

// .zmk.keymap.Keymap ok = 1;
inline bool SetActivePhysicalLayoutResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool SetActivePhysicalLayoutResponse::has_ok() const {
  return _internal_has_ok();
}
inline void SetActivePhysicalLayoutResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void SetActivePhysicalLayoutResponse::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ok_;
    }
    clear_has_result();
  }
}
inline ::zmk::keymap::Keymap* SetActivePhysicalLayoutResponse::release_ok() {
  // @@protoc_insertion_point(field_release:zmk.keymap.SetActivePhysicalLayoutResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Keymap* temp = _impl_.result_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Keymap& SetActivePhysicalLayoutResponse::_internal_ok() const {
  return _internal_has_ok()
      ? *_impl_.result_.ok_
      : reinterpret_cast< ::zmk::keymap::Keymap&>(::zmk::keymap::_Keymap_default_instance_);
}
inline const ::zmk::keymap::Keymap& SetActivePhysicalLayoutResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetActivePhysicalLayoutResponse.ok)
  return _internal_ok();
}
inline ::zmk::keymap::Keymap* SetActivePhysicalLayoutResponse::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.SetActivePhysicalLayoutResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Keymap* temp = _impl_.result_.ok_;
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SetActivePhysicalLayoutResponse::unsafe_arena_set_allocated_ok(::zmk::keymap::Keymap* ok) {
  clear_result();
  if (ok) {
    set_has_ok();
    _impl_.result_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.SetActivePhysicalLayoutResponse.ok)
}
inline ::zmk::keymap::Keymap* SetActivePhysicalLayoutResponse::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
    _impl_.result_.ok_ = CreateMaybeMessage< ::zmk::keymap::Keymap >(GetArenaForAllocation());
  }
  return _impl_.result_.ok_;
}
inline ::zmk::keymap::Keymap* SetActivePhysicalLayoutResponse::mutable_ok() {
  ::zmk::keymap::Keymap* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.SetActivePhysicalLayoutResponse.ok)
  return _msg;
}

// .zmk.keymap.SetActivePhysicalLayoutErrorCode err = 2;
inline bool SetActivePhysicalLayoutResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool SetActivePhysicalLayoutResponse::has_err() const {
  return _internal_has_err();
}
inline void SetActivePhysicalLayoutResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void SetActivePhysicalLayoutResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::SetActivePhysicalLayoutErrorCode SetActivePhysicalLayoutResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::SetActivePhysicalLayoutErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::SetActivePhysicalLayoutErrorCode >(0);
}
inline ::zmk::keymap::SetActivePhysicalLayoutErrorCode SetActivePhysicalLayoutResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetActivePhysicalLayoutResponse.err)
  return _internal_err();
}
inline void SetActivePhysicalLayoutResponse::_internal_set_err(::zmk::keymap::SetActivePhysicalLayoutErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void SetActivePhysicalLayoutResponse::set_err(::zmk::keymap::SetActivePhysicalLayoutErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SetActivePhysicalLayoutResponse.err)
}

inline bool SetActivePhysicalLayoutResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void SetActivePhysicalLayoutResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline SetActivePhysicalLayoutResponse::ResultCase SetActivePhysicalLayoutResponse::result_case() const {
  return SetActivePhysicalLayoutResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// MoveLayerResponse

// .zmk.keymap.Keymap ok = 1;
inline bool MoveLayerResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool MoveLayerResponse::has_ok() const {
  return _internal_has_ok();
}
inline void MoveLayerResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void MoveLayerResponse::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ok_;
    }
    clear_has_result();
  }
}
inline ::zmk::keymap::Keymap* MoveLayerResponse::release_ok() {
  // @@protoc_insertion_point(field_release:zmk.keymap.MoveLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Keymap* temp = _impl_.result_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Keymap& MoveLayerResponse::_internal_ok() const {
  return _internal_has_ok()
      ? *_impl_.result_.ok_
      : reinterpret_cast< ::zmk::keymap::Keymap&>(::zmk::keymap::_Keymap_default_instance_);
}
inline const ::zmk::keymap::Keymap& MoveLayerResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.MoveLayerResponse.ok)
  return _internal_ok();
}
inline ::zmk::keymap::Keymap* MoveLayerResponse::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.MoveLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Keymap* temp = _impl_.result_.ok_;
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void MoveLayerResponse::unsafe_arena_set_allocated_ok(::zmk::keymap::Keymap* ok) {
  clear_result();
  if (ok) {
    set_has_ok();
    _impl_.result_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.MoveLayerResponse.ok)
}
inline ::zmk::keymap::Keymap* MoveLayerResponse::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
    _impl_.result_.ok_ = CreateMaybeMessage< ::zmk::keymap::Keymap >(GetArenaForAllocation());
  }
  return _impl_.result_.ok_;
}
inline ::zmk::keymap::Keymap* MoveLayerResponse::mutable_ok() {
  ::zmk::keymap::Keymap* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.MoveLayerResponse.ok)
  return _msg;
}

// .zmk.keymap.MoveLayerErrorCode err = 2;
inline bool MoveLayerResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool MoveLayerResponse::has_err() const {
  return _internal_has_err();
}
inline void MoveLayerResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void MoveLayerResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::MoveLayerErrorCode MoveLayerResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::MoveLayerErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::MoveLayerErrorCode >(0);
}
inline ::zmk::keymap::MoveLayerErrorCode MoveLayerResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.MoveLayerResponse.err)
  return _internal_err();
}
inline void MoveLayerResponse::_internal_set_err(::zmk::keymap::MoveLayerErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void MoveLayerResponse::set_err(::zmk::keymap::MoveLayerErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.MoveLayerResponse.err)
}

inline bool MoveLayerResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void MoveLayerResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline MoveLayerResponse::ResultCase MoveLayerResponse::result_case() const {
  return MoveLayerResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddLayerResponse

// .zmk.keymap.AddLayerResponseDetails ok = 1;
inline bool AddLayerResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool AddLayerResponse::has_ok() const {
  return _internal_has_ok();
}
inline void AddLayerResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void AddLayerResponse::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ok_;
    }
    clear_has_result();
  }
}
inline ::zmk::keymap::AddLayerResponseDetails* AddLayerResponse::release_ok() {
  // @@protoc_insertion_point(field_release:zmk.keymap.AddLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::AddLayerResponseDetails* temp = _impl_.result_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::AddLayerResponseDetails& AddLayerResponse::_internal_ok() const {
  return _internal_has_ok()
      ? *_impl_.result_.ok_
      : reinterpret_cast< ::zmk::keymap::AddLayerResponseDetails&>(::zmk::keymap::_AddLayerResponseDetails_default_instance_);
}
inline const ::zmk::keymap::AddLayerResponseDetails& AddLayerResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.AddLayerResponse.ok)
  return _internal_ok();
}
inline ::zmk::keymap::AddLayerResponseDetails* AddLayerResponse::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.AddLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::AddLayerResponseDetails* temp = _impl_.result_.ok_;
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AddLayerResponse::unsafe_arena_set_allocated_ok(::zmk::keymap::AddLayerResponseDetails* ok) {
  clear_result();
  if (ok) {
    set_has_ok();
    _impl_.result_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.AddLayerResponse.ok)
}
inline ::zmk::keymap::AddLayerResponseDetails* AddLayerResponse::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
    _impl_.result_.ok_ = CreateMaybeMessage< ::zmk::keymap::AddLayerResponseDetails >(GetArenaForAllocation());
  }
  return _impl_.result_.ok_;
}
inline ::zmk::keymap::AddLayerResponseDetails* AddLayerResponse::mutable_ok() {
  ::zmk::keymap::AddLayerResponseDetails* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.AddLayerResponse.ok)
  return _msg;
}

// .zmk.keymap.AddLayerErrorCode err = 2;
inline bool AddLayerResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool AddLayerResponse::has_err() const {
  return _internal_has_err();
}
inline void AddLayerResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void AddLayerResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::AddLayerErrorCode AddLayerResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::AddLayerErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::AddLayerErrorCode >(0);
}
inline ::zmk::keymap::AddLayerErrorCode AddLayerResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.AddLayerResponse.err)
  return _internal_err();
}
inline void AddLayerResponse::_internal_set_err(::zmk::keymap::AddLayerErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void AddLayerResponse::set_err(::zmk::keymap::AddLayerErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.AddLayerResponse.err)
}

inline bool AddLayerResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void AddLayerResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline AddLayerResponse::ResultCase AddLayerResponse::result_case() const {
  return AddLayerResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AddLayerResponseDetails

// uint32 index = 1;
inline void AddLayerResponseDetails::clear_index() {
  _impl_.index_ = 0u;
}
inline uint32_t AddLayerResponseDetails::_internal_index() const {
  return _impl_.index_;
}
inline uint32_t AddLayerResponseDetails::index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.AddLayerResponseDetails.index)
  return _internal_index();
}
inline void AddLayerResponseDetails::_internal_set_index(uint32_t value) {
  
  _impl_.index_ = value;
}
inline void AddLayerResponseDetails::set_index(uint32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.AddLayerResponseDetails.index)
}

// .zmk.keymap.Layer layer = 2;
inline bool AddLayerResponseDetails::_internal_has_layer() const {
  return this != internal_default_instance() && _impl_.layer_ != nullptr;
}
inline bool AddLayerResponseDetails::has_layer() const {
  return _internal_has_layer();
}
inline void AddLayerResponseDetails::clear_layer() {
  if (GetArenaForAllocation() == nullptr && _impl_.layer_ != nullptr) {
    delete _impl_.layer_;
  }
  _impl_.layer_ = nullptr;
}
inline const ::zmk::keymap::Layer& AddLayerResponseDetails::_internal_layer() const {
  const ::zmk::keymap::Layer* p = _impl_.layer_;
  return p != nullptr ? *p : reinterpret_cast<const ::zmk::keymap::Layer&>(
      ::zmk::keymap::_Layer_default_instance_);
}
inline const ::zmk::keymap::Layer& AddLayerResponseDetails::layer() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.AddLayerResponseDetails.layer)
  return _internal_layer();
}
inline void AddLayerResponseDetails::unsafe_arena_set_allocated_layer(
    ::zmk::keymap::Layer* layer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.layer_);
  }
  _impl_.layer_ = layer;
  if (layer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.AddLayerResponseDetails.layer)
}
inline ::zmk::keymap::Layer* AddLayerResponseDetails::release_layer() {
  
  ::zmk::keymap::Layer* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zmk::keymap::Layer* AddLayerResponseDetails::unsafe_arena_release_layer() {
  // @@protoc_insertion_point(field_release:zmk.keymap.AddLayerResponseDetails.layer)
  
  ::zmk::keymap::Layer* temp = _impl_.layer_;
  _impl_.layer_ = nullptr;
  return temp;
}
inline ::zmk::keymap::Layer* AddLayerResponseDetails::_internal_mutable_layer() {
  
  if (_impl_.layer_ == nullptr) {
    auto* p = CreateMaybeMessage<::zmk::keymap::Layer>(GetArenaForAllocation());
    _impl_.layer_ = p;
  }
  return _impl_.layer_;
}
inline ::zmk::keymap::Layer* AddLayerResponseDetails::mutable_layer() {
  ::zmk::keymap::Layer* _msg = _internal_mutable_layer();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.AddLayerResponseDetails.layer)
  return _msg;
}
inline void AddLayerResponseDetails::set_allocated_layer(::zmk::keymap::Layer* layer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.layer_;
  }
  if (layer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(layer);
    if (message_arena != submessage_arena) {
      layer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, layer, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.layer_ = layer;
  // @@protoc_insertion_point(field_set_allocated:zmk.keymap.AddLayerResponseDetails.layer)
}

// -------------------------------------------------------------------

// RemoveLayerResponse

// .zmk.keymap.RemoveLayerOk ok = 1;
inline bool RemoveLayerResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool RemoveLayerResponse::has_ok() const {
  return _internal_has_ok();
}
inline void RemoveLayerResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void RemoveLayerResponse::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ok_;
    }
    clear_has_result();
  }
}
inline ::zmk::keymap::RemoveLayerOk* RemoveLayerResponse::release_ok() {
  // @@protoc_insertion_point(field_release:zmk.keymap.RemoveLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::RemoveLayerOk* temp = _impl_.result_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::RemoveLayerOk& RemoveLayerResponse::_internal_ok() const {
  return _internal_has_ok()
      ? *_impl_.result_.ok_
      : reinterpret_cast< ::zmk::keymap::RemoveLayerOk&>(::zmk::keymap::_RemoveLayerOk_default_instance_);
}
inline const ::zmk::keymap::RemoveLayerOk& RemoveLayerResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RemoveLayerResponse.ok)
  return _internal_ok();
}
inline ::zmk::keymap::RemoveLayerOk* RemoveLayerResponse::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.RemoveLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::RemoveLayerOk* temp = _impl_.result_.ok_;
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RemoveLayerResponse::unsafe_arena_set_allocated_ok(::zmk::keymap::RemoveLayerOk* ok) {
  clear_result();
  if (ok) {
    set_has_ok();
    _impl_.result_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.RemoveLayerResponse.ok)
}
inline ::zmk::keymap::RemoveLayerOk* RemoveLayerResponse::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
    _impl_.result_.ok_ = CreateMaybeMessage< ::zmk::keymap::RemoveLayerOk >(GetArenaForAllocation());
  }
  return _impl_.result_.ok_;
}
inline ::zmk::keymap::RemoveLayerOk* RemoveLayerResponse::mutable_ok() {
  ::zmk::keymap::RemoveLayerOk* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.RemoveLayerResponse.ok)
  return _msg;
}

// .zmk.keymap.RemoveLayerErrorCode err = 2;
inline bool RemoveLayerResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool RemoveLayerResponse::has_err() const {
  return _internal_has_err();
}
inline void RemoveLayerResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void RemoveLayerResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::RemoveLayerErrorCode RemoveLayerResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::RemoveLayerErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::RemoveLayerErrorCode >(0);
}
inline ::zmk::keymap::RemoveLayerErrorCode RemoveLayerResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RemoveLayerResponse.err)
  return _internal_err();
}
inline void RemoveLayerResponse::_internal_set_err(::zmk::keymap::RemoveLayerErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void RemoveLayerResponse::set_err(::zmk::keymap::RemoveLayerErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.RemoveLayerResponse.err)
}

inline bool RemoveLayerResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void RemoveLayerResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline RemoveLayerResponse::ResultCase RemoveLayerResponse::result_case() const {
  return RemoveLayerResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RemoveLayerOk

// -------------------------------------------------------------------

// RestoreLayerResponse

// .zmk.keymap.Layer ok = 1;
inline bool RestoreLayerResponse::_internal_has_ok() const {
  return result_case() == kOk;
}
inline bool RestoreLayerResponse::has_ok() const {
  return _internal_has_ok();
}
inline void RestoreLayerResponse::set_has_ok() {
  _impl_._oneof_case_[0] = kOk;
}
inline void RestoreLayerResponse::clear_ok() {
  if (_internal_has_ok()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.result_.ok_;
    }
    clear_has_result();
  }
}
inline ::zmk::keymap::Layer* RestoreLayerResponse::release_ok() {
  // @@protoc_insertion_point(field_release:zmk.keymap.RestoreLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Layer* temp = _impl_.result_.ok_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::zmk::keymap::Layer& RestoreLayerResponse::_internal_ok() const {
  return _internal_has_ok()
      ? *_impl_.result_.ok_
      : reinterpret_cast< ::zmk::keymap::Layer&>(::zmk::keymap::_Layer_default_instance_);
}
inline const ::zmk::keymap::Layer& RestoreLayerResponse::ok() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RestoreLayerResponse.ok)
  return _internal_ok();
}
inline ::zmk::keymap::Layer* RestoreLayerResponse::unsafe_arena_release_ok() {
  // @@protoc_insertion_point(field_unsafe_arena_release:zmk.keymap.RestoreLayerResponse.ok)
  if (_internal_has_ok()) {
    clear_has_result();
    ::zmk::keymap::Layer* temp = _impl_.result_.ok_;
    _impl_.result_.ok_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RestoreLayerResponse::unsafe_arena_set_allocated_ok(::zmk::keymap::Layer* ok) {
  clear_result();
  if (ok) {
    set_has_ok();
    _impl_.result_.ok_ = ok;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.RestoreLayerResponse.ok)
}
inline ::zmk::keymap::Layer* RestoreLayerResponse::_internal_mutable_ok() {
  if (!_internal_has_ok()) {
    clear_result();
    set_has_ok();
    _impl_.result_.ok_ = CreateMaybeMessage< ::zmk::keymap::Layer >(GetArenaForAllocation());
  }
  return _impl_.result_.ok_;
}
inline ::zmk::keymap::Layer* RestoreLayerResponse::mutable_ok() {
  ::zmk::keymap::Layer* _msg = _internal_mutable_ok();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.RestoreLayerResponse.ok)
  return _msg;
}

// .zmk.keymap.RestoreLayerErrorCode err = 2;
inline bool RestoreLayerResponse::_internal_has_err() const {
  return result_case() == kErr;
}
inline bool RestoreLayerResponse::has_err() const {
  return _internal_has_err();
}
inline void RestoreLayerResponse::set_has_err() {
  _impl_._oneof_case_[0] = kErr;
}
inline void RestoreLayerResponse::clear_err() {
  if (_internal_has_err()) {
    _impl_.result_.err_ = 0;
    clear_has_result();
  }
}
inline ::zmk::keymap::RestoreLayerErrorCode RestoreLayerResponse::_internal_err() const {
  if (_internal_has_err()) {
    return static_cast< ::zmk::keymap::RestoreLayerErrorCode >(_impl_.result_.err_);
  }
  return static_cast< ::zmk::keymap::RestoreLayerErrorCode >(0);
}
inline ::zmk::keymap::RestoreLayerErrorCode RestoreLayerResponse::err() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RestoreLayerResponse.err)
  return _internal_err();
}
inline void RestoreLayerResponse::_internal_set_err(::zmk::keymap::RestoreLayerErrorCode value) {
  if (!_internal_has_err()) {
    clear_result();
    set_has_err();
  }
  _impl_.result_.err_ = value;
}
inline void RestoreLayerResponse::set_err(::zmk::keymap::RestoreLayerErrorCode value) {
  _internal_set_err(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.RestoreLayerResponse.err)
}

inline bool RestoreLayerResponse::has_result() const {
  return result_case() != RESULT_NOT_SET;
}
inline void RestoreLayerResponse::clear_has_result() {
  _impl_._oneof_case_[0] = RESULT_NOT_SET;
}
inline RestoreLayerResponse::ResultCase RestoreLayerResponse::result_case() const {
  return RestoreLayerResponse::ResultCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetLayerBindingRequest

// uint32 layer_id = 1;
inline void SetLayerBindingRequest::clear_layer_id() {
  _impl_.layer_id_ = 0u;
}
inline uint32_t SetLayerBindingRequest::_internal_layer_id() const {
  return _impl_.layer_id_;
}
inline uint32_t SetLayerBindingRequest::layer_id() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetLayerBindingRequest.layer_id)
  return _internal_layer_id();
}
inline void SetLayerBindingRequest::_internal_set_layer_id(uint32_t value) {
  
  _impl_.layer_id_ = value;
}
inline void SetLayerBindingRequest::set_layer_id(uint32_t value) {
  _internal_set_layer_id(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SetLayerBindingRequest.layer_id)
}

// int32 key_position = 2;
inline void SetLayerBindingRequest::clear_key_position() {
  _impl_.key_position_ = 0;
}
inline int32_t SetLayerBindingRequest::_internal_key_position() const {
  return _impl_.key_position_;
}
inline int32_t SetLayerBindingRequest::key_position() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetLayerBindingRequest.key_position)
  return _internal_key_position();
}
inline void SetLayerBindingRequest::_internal_set_key_position(int32_t value) {
  
  _impl_.key_position_ = value;
}
inline void SetLayerBindingRequest::set_key_position(int32_t value) {
  _internal_set_key_position(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SetLayerBindingRequest.key_position)
}

// .zmk.keymap.BehaviorBinding binding = 3;
inline bool SetLayerBindingRequest::_internal_has_binding() const {
  return this != internal_default_instance() && _impl_.binding_ != nullptr;
}
inline bool SetLayerBindingRequest::has_binding() const {
  return _internal_has_binding();
}
inline void SetLayerBindingRequest::clear_binding() {
  if (GetArenaForAllocation() == nullptr && _impl_.binding_ != nullptr) {
    delete _impl_.binding_;
  }
  _impl_.binding_ = nullptr;
}
inline const ::zmk::keymap::BehaviorBinding& SetLayerBindingRequest::_internal_binding() const {
  const ::zmk::keymap::BehaviorBinding* p = _impl_.binding_;
  return p != nullptr ? *p : reinterpret_cast<const ::zmk::keymap::BehaviorBinding&>(
      ::zmk::keymap::_BehaviorBinding_default_instance_);
}
inline const ::zmk::keymap::BehaviorBinding& SetLayerBindingRequest::binding() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetLayerBindingRequest.binding)
  return _internal_binding();
}
inline void SetLayerBindingRequest::unsafe_arena_set_allocated_binding(
    ::zmk::keymap::BehaviorBinding* binding) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.binding_);
  }
  _impl_.binding_ = binding;
  if (binding) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:zmk.keymap.SetLayerBindingRequest.binding)
}
inline ::zmk::keymap::BehaviorBinding* SetLayerBindingRequest::release_binding() {
  
  ::zmk::keymap::BehaviorBinding* temp = _impl_.binding_;
  _impl_.binding_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::zmk::keymap::BehaviorBinding* SetLayerBindingRequest::unsafe_arena_release_binding() {
  // @@protoc_insertion_point(field_release:zmk.keymap.SetLayerBindingRequest.binding)
  
  ::zmk::keymap::BehaviorBinding* temp = _impl_.binding_;
  _impl_.binding_ = nullptr;
  return temp;
}
inline ::zmk::keymap::BehaviorBinding* SetLayerBindingRequest::_internal_mutable_binding() {
  
  if (_impl_.binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::zmk::keymap::BehaviorBinding>(GetArenaForAllocation());
    _impl_.binding_ = p;
  }
  return _impl_.binding_;
}
inline ::zmk::keymap::BehaviorBinding* SetLayerBindingRequest::mutable_binding() {
  ::zmk::keymap::BehaviorBinding* _msg = _internal_mutable_binding();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.SetLayerBindingRequest.binding)
  return _msg;
}
inline void SetLayerBindingRequest::set_allocated_binding(::zmk::keymap::BehaviorBinding* binding) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.binding_;
  }
  if (binding) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(binding);
    if (message_arena != submessage_arena) {
      binding = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:zmk.keymap.SetLayerBindingRequest.binding)
}

// -------------------------------------------------------------------

// MoveLayerRequest

// uint32 start_index = 1;
inline void MoveLayerRequest::clear_start_index() {
  _impl_.start_index_ = 0u;
}
inline uint32_t MoveLayerRequest::_internal_start_index() const {
  return _impl_.start_index_;
}
inline uint32_t MoveLayerRequest::start_index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.MoveLayerRequest.start_index)
  return _internal_start_index();
}
inline void MoveLayerRequest::_internal_set_start_index(uint32_t value) {
  
  _impl_.start_index_ = value;
}
inline void MoveLayerRequest::set_start_index(uint32_t value) {
  _internal_set_start_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.MoveLayerRequest.start_index)
}

// uint32 dest_index = 2;
inline void MoveLayerRequest::clear_dest_index() {
  _impl_.dest_index_ = 0u;
}
inline uint32_t MoveLayerRequest::_internal_dest_index() const {
  return _impl_.dest_index_;
}
inline uint32_t MoveLayerRequest::dest_index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.MoveLayerRequest.dest_index)
  return _internal_dest_index();
}
inline void MoveLayerRequest::_internal_set_dest_index(uint32_t value) {
  
  _impl_.dest_index_ = value;
}
inline void MoveLayerRequest::set_dest_index(uint32_t value) {
  _internal_set_dest_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.MoveLayerRequest.dest_index)
}

// -------------------------------------------------------------------

// AddLayerRequest

// -------------------------------------------------------------------

// RemoveLayerRequest

// uint32 layer_index = 1;
inline void RemoveLayerRequest::clear_layer_index() {
  _impl_.layer_index_ = 0u;
}
inline uint32_t RemoveLayerRequest::_internal_layer_index() const {
  return _impl_.layer_index_;
}
inline uint32_t RemoveLayerRequest::layer_index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RemoveLayerRequest.layer_index)
  return _internal_layer_index();
}
inline void RemoveLayerRequest::_internal_set_layer_index(uint32_t value) {
  
  _impl_.layer_index_ = value;
}
inline void RemoveLayerRequest::set_layer_index(uint32_t value) {
  _internal_set_layer_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.RemoveLayerRequest.layer_index)
}

// -------------------------------------------------------------------

// RestoreLayerRequest

// uint32 layer_id = 1;
inline void RestoreLayerRequest::clear_layer_id() {
  _impl_.layer_id_ = 0u;
}
inline uint32_t RestoreLayerRequest::_internal_layer_id() const {
  return _impl_.layer_id_;
}
inline uint32_t RestoreLayerRequest::layer_id() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RestoreLayerRequest.layer_id)
  return _internal_layer_id();
}
inline void RestoreLayerRequest::_internal_set_layer_id(uint32_t value) {
  
  _impl_.layer_id_ = value;
}
inline void RestoreLayerRequest::set_layer_id(uint32_t value) {
  _internal_set_layer_id(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.RestoreLayerRequest.layer_id)
}

// uint32 at_index = 2;
inline void RestoreLayerRequest::clear_at_index() {
  _impl_.at_index_ = 0u;
}
inline uint32_t RestoreLayerRequest::_internal_at_index() const {
  return _impl_.at_index_;
}
inline uint32_t RestoreLayerRequest::at_index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.RestoreLayerRequest.at_index)
  return _internal_at_index();
}
inline void RestoreLayerRequest::_internal_set_at_index(uint32_t value) {
  
  _impl_.at_index_ = value;
}
inline void RestoreLayerRequest::set_at_index(uint32_t value) {
  _internal_set_at_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.RestoreLayerRequest.at_index)
}

// -------------------------------------------------------------------

// SetLayerPropsRequest

// uint32 layer_id = 1;
inline void SetLayerPropsRequest::clear_layer_id() {
  _impl_.layer_id_ = 0u;
}
inline uint32_t SetLayerPropsRequest::_internal_layer_id() const {
  return _impl_.layer_id_;
}
inline uint32_t SetLayerPropsRequest::layer_id() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetLayerPropsRequest.layer_id)
  return _internal_layer_id();
}
inline void SetLayerPropsRequest::_internal_set_layer_id(uint32_t value) {
  
  _impl_.layer_id_ = value;
}
inline void SetLayerPropsRequest::set_layer_id(uint32_t value) {
  _internal_set_layer_id(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.SetLayerPropsRequest.layer_id)
}

// string name = 2;
inline void SetLayerPropsRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SetLayerPropsRequest::name() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.SetLayerPropsRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetLayerPropsRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zmk.keymap.SetLayerPropsRequest.name)
}
inline std::string* SetLayerPropsRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.SetLayerPropsRequest.name)
  return _s;
}
inline const std::string& SetLayerPropsRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SetLayerPropsRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SetLayerPropsRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SetLayerPropsRequest::release_name() {
  // @@protoc_insertion_point(field_release:zmk.keymap.SetLayerPropsRequest.name)
  return _impl_.name_.Release();
}
inline void SetLayerPropsRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zmk.keymap.SetLayerPropsRequest.name)
}

// -------------------------------------------------------------------

// Keymap

// repeated .zmk.keymap.Layer layers = 1;
inline int Keymap::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int Keymap::layers_size() const {
  return _internal_layers_size();
}
inline void Keymap::clear_layers() {
  _impl_.layers_.Clear();
}
inline ::zmk::keymap::Layer* Keymap::mutable_layers(int index) {
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Keymap.layers)
  return _impl_.layers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::Layer >*
Keymap::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_list:zmk.keymap.Keymap.layers)
  return &_impl_.layers_;
}
inline const ::zmk::keymap::Layer& Keymap::_internal_layers(int index) const {
  return _impl_.layers_.Get(index);
}
inline const ::zmk::keymap::Layer& Keymap::layers(int index) const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Keymap.layers)
  return _internal_layers(index);
}
inline ::zmk::keymap::Layer* Keymap::_internal_add_layers() {
  return _impl_.layers_.Add();
}
inline ::zmk::keymap::Layer* Keymap::add_layers() {
  ::zmk::keymap::Layer* _add = _internal_add_layers();
  // @@protoc_insertion_point(field_add:zmk.keymap.Keymap.layers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::Layer >&
Keymap::layers() const {
  // @@protoc_insertion_point(field_list:zmk.keymap.Keymap.layers)
  return _impl_.layers_;
}

// uint32 available_layers = 2;
inline void Keymap::clear_available_layers() {
  _impl_.available_layers_ = 0u;
}
inline uint32_t Keymap::_internal_available_layers() const {
  return _impl_.available_layers_;
}
inline uint32_t Keymap::available_layers() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Keymap.available_layers)
  return _internal_available_layers();
}
inline void Keymap::_internal_set_available_layers(uint32_t value) {
  
  _impl_.available_layers_ = value;
}
inline void Keymap::set_available_layers(uint32_t value) {
  _internal_set_available_layers(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Keymap.available_layers)
}

// uint32 max_layer_name_length = 3;
inline void Keymap::clear_max_layer_name_length() {
  _impl_.max_layer_name_length_ = 0u;
}
inline uint32_t Keymap::_internal_max_layer_name_length() const {
  return _impl_.max_layer_name_length_;
}
inline uint32_t Keymap::max_layer_name_length() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Keymap.max_layer_name_length)
  return _internal_max_layer_name_length();
}
inline void Keymap::_internal_set_max_layer_name_length(uint32_t value) {
  
  _impl_.max_layer_name_length_ = value;
}
inline void Keymap::set_max_layer_name_length(uint32_t value) {
  _internal_set_max_layer_name_length(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Keymap.max_layer_name_length)
}

// -------------------------------------------------------------------

// Layer

// uint32 id = 1;
inline void Layer::clear_id() {
  _impl_.id_ = 0u;
}
inline uint32_t Layer::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Layer::id() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Layer.id)
  return _internal_id();
}
inline void Layer::_internal_set_id(uint32_t value) {
  
  _impl_.id_ = value;
}
inline void Layer::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.Layer.id)
}

// string name = 2;
inline void Layer::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Layer::name() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Layer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Layer::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zmk.keymap.Layer.name)
}
inline std::string* Layer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Layer.name)
  return _s;
}
inline const std::string& Layer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Layer::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Layer::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Layer::release_name() {
  // @@protoc_insertion_point(field_release:zmk.keymap.Layer.name)
  return _impl_.name_.Release();
}
inline void Layer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zmk.keymap.Layer.name)
}

// repeated .zmk.keymap.BehaviorBinding bindings = 3;
inline int Layer::_internal_bindings_size() const {
  return _impl_.bindings_.size();
}
inline int Layer::bindings_size() const {
  return _internal_bindings_size();
}
inline void Layer::clear_bindings() {
  _impl_.bindings_.Clear();
}
inline ::zmk::keymap::BehaviorBinding* Layer::mutable_bindings(int index) {
  // @@protoc_insertion_point(field_mutable:zmk.keymap.Layer.bindings)
  return _impl_.bindings_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::BehaviorBinding >*
Layer::mutable_bindings() {
  // @@protoc_insertion_point(field_mutable_list:zmk.keymap.Layer.bindings)
  return &_impl_.bindings_;
}
inline const ::zmk::keymap::BehaviorBinding& Layer::_internal_bindings(int index) const {
  return _impl_.bindings_.Get(index);
}
inline const ::zmk::keymap::BehaviorBinding& Layer::bindings(int index) const {
  // @@protoc_insertion_point(field_get:zmk.keymap.Layer.bindings)
  return _internal_bindings(index);
}
inline ::zmk::keymap::BehaviorBinding* Layer::_internal_add_bindings() {
  return _impl_.bindings_.Add();
}
inline ::zmk::keymap::BehaviorBinding* Layer::add_bindings() {
  ::zmk::keymap::BehaviorBinding* _add = _internal_add_bindings();
  // @@protoc_insertion_point(field_add:zmk.keymap.Layer.bindings)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::BehaviorBinding >&
Layer::bindings() const {
  // @@protoc_insertion_point(field_list:zmk.keymap.Layer.bindings)
  return _impl_.bindings_;
}

// -------------------------------------------------------------------

// BehaviorBinding

// sint32 behavior_id = 1;
inline void BehaviorBinding::clear_behavior_id() {
  _impl_.behavior_id_ = 0;
}
inline int32_t BehaviorBinding::_internal_behavior_id() const {
  return _impl_.behavior_id_;
}
inline int32_t BehaviorBinding::behavior_id() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.BehaviorBinding.behavior_id)
  return _internal_behavior_id();
}
inline void BehaviorBinding::_internal_set_behavior_id(int32_t value) {
  
  _impl_.behavior_id_ = value;
}
inline void BehaviorBinding::set_behavior_id(int32_t value) {
  _internal_set_behavior_id(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.BehaviorBinding.behavior_id)
}

// uint32 param1 = 2;
inline void BehaviorBinding::clear_param1() {
  _impl_.param1_ = 0u;
}
inline uint32_t BehaviorBinding::_internal_param1() const {
  return _impl_.param1_;
}
inline uint32_t BehaviorBinding::param1() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.BehaviorBinding.param1)
  return _internal_param1();
}
inline void BehaviorBinding::_internal_set_param1(uint32_t value) {
  
  _impl_.param1_ = value;
}
inline void BehaviorBinding::set_param1(uint32_t value) {
  _internal_set_param1(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.BehaviorBinding.param1)
}

// uint32 param2 = 3;
inline void BehaviorBinding::clear_param2() {
  _impl_.param2_ = 0u;
}
inline uint32_t BehaviorBinding::_internal_param2() const {
  return _impl_.param2_;
}
inline uint32_t BehaviorBinding::param2() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.BehaviorBinding.param2)
  return _internal_param2();
}
inline void BehaviorBinding::_internal_set_param2(uint32_t value) {
  
  _impl_.param2_ = value;
}
inline void BehaviorBinding::set_param2(uint32_t value) {
  _internal_set_param2(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.BehaviorBinding.param2)
}

// -------------------------------------------------------------------

// PhysicalLayouts

// uint32 active_layout_index = 1;
inline void PhysicalLayouts::clear_active_layout_index() {
  _impl_.active_layout_index_ = 0u;
}
inline uint32_t PhysicalLayouts::_internal_active_layout_index() const {
  return _impl_.active_layout_index_;
}
inline uint32_t PhysicalLayouts::active_layout_index() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.PhysicalLayouts.active_layout_index)
  return _internal_active_layout_index();
}
inline void PhysicalLayouts::_internal_set_active_layout_index(uint32_t value) {
  
  _impl_.active_layout_index_ = value;
}
inline void PhysicalLayouts::set_active_layout_index(uint32_t value) {
  _internal_set_active_layout_index(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.PhysicalLayouts.active_layout_index)
}

// repeated .zmk.keymap.PhysicalLayout layouts = 2;
inline int PhysicalLayouts::_internal_layouts_size() const {
  return _impl_.layouts_.size();
}
inline int PhysicalLayouts::layouts_size() const {
  return _internal_layouts_size();
}
inline void PhysicalLayouts::clear_layouts() {
  _impl_.layouts_.Clear();
}
inline ::zmk::keymap::PhysicalLayout* PhysicalLayouts::mutable_layouts(int index) {
  // @@protoc_insertion_point(field_mutable:zmk.keymap.PhysicalLayouts.layouts)
  return _impl_.layouts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::PhysicalLayout >*
PhysicalLayouts::mutable_layouts() {
  // @@protoc_insertion_point(field_mutable_list:zmk.keymap.PhysicalLayouts.layouts)
  return &_impl_.layouts_;
}
inline const ::zmk::keymap::PhysicalLayout& PhysicalLayouts::_internal_layouts(int index) const {
  return _impl_.layouts_.Get(index);
}
inline const ::zmk::keymap::PhysicalLayout& PhysicalLayouts::layouts(int index) const {
  // @@protoc_insertion_point(field_get:zmk.keymap.PhysicalLayouts.layouts)
  return _internal_layouts(index);
}
inline ::zmk::keymap::PhysicalLayout* PhysicalLayouts::_internal_add_layouts() {
  return _impl_.layouts_.Add();
}
inline ::zmk::keymap::PhysicalLayout* PhysicalLayouts::add_layouts() {
  ::zmk::keymap::PhysicalLayout* _add = _internal_add_layouts();
  // @@protoc_insertion_point(field_add:zmk.keymap.PhysicalLayouts.layouts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::PhysicalLayout >&
PhysicalLayouts::layouts() const {
  // @@protoc_insertion_point(field_list:zmk.keymap.PhysicalLayouts.layouts)
  return _impl_.layouts_;
}

// -------------------------------------------------------------------

// PhysicalLayout

// string name = 1;
inline void PhysicalLayout::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PhysicalLayout::name() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.PhysicalLayout.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PhysicalLayout::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:zmk.keymap.PhysicalLayout.name)
}
inline std::string* PhysicalLayout::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:zmk.keymap.PhysicalLayout.name)
  return _s;
}
inline const std::string& PhysicalLayout::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PhysicalLayout::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PhysicalLayout::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PhysicalLayout::release_name() {
  // @@protoc_insertion_point(field_release:zmk.keymap.PhysicalLayout.name)
  return _impl_.name_.Release();
}
inline void PhysicalLayout::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:zmk.keymap.PhysicalLayout.name)
}

// repeated .zmk.keymap.KeyPhysicalAttrs keys = 2;
inline int PhysicalLayout::_internal_keys_size() const {
  return _impl_.keys_.size();
}
inline int PhysicalLayout::keys_size() const {
  return _internal_keys_size();
}
inline void PhysicalLayout::clear_keys() {
  _impl_.keys_.Clear();
}
inline ::zmk::keymap::KeyPhysicalAttrs* PhysicalLayout::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:zmk.keymap.PhysicalLayout.keys)
  return _impl_.keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::KeyPhysicalAttrs >*
PhysicalLayout::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:zmk.keymap.PhysicalLayout.keys)
  return &_impl_.keys_;
}
inline const ::zmk::keymap::KeyPhysicalAttrs& PhysicalLayout::_internal_keys(int index) const {
  return _impl_.keys_.Get(index);
}
inline const ::zmk::keymap::KeyPhysicalAttrs& PhysicalLayout::keys(int index) const {
  // @@protoc_insertion_point(field_get:zmk.keymap.PhysicalLayout.keys)
  return _internal_keys(index);
}
inline ::zmk::keymap::KeyPhysicalAttrs* PhysicalLayout::_internal_add_keys() {
  return _impl_.keys_.Add();
}
inline ::zmk::keymap::KeyPhysicalAttrs* PhysicalLayout::add_keys() {
  ::zmk::keymap::KeyPhysicalAttrs* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:zmk.keymap.PhysicalLayout.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::zmk::keymap::KeyPhysicalAttrs >&
PhysicalLayout::keys() const {
  // @@protoc_insertion_point(field_list:zmk.keymap.PhysicalLayout.keys)
  return _impl_.keys_;
}

// -------------------------------------------------------------------

// KeyPhysicalAttrs

// sint32 width = 1;
inline void KeyPhysicalAttrs::clear_width() {
  _impl_.width_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_width() const {
  return _impl_.width_;
}
inline int32_t KeyPhysicalAttrs::width() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.width)
  return _internal_width();
}
inline void KeyPhysicalAttrs::_internal_set_width(int32_t value) {
  
  _impl_.width_ = value;
}
inline void KeyPhysicalAttrs::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.width)
}

// sint32 height = 2;
inline void KeyPhysicalAttrs::clear_height() {
  _impl_.height_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_height() const {
  return _impl_.height_;
}
inline int32_t KeyPhysicalAttrs::height() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.height)
  return _internal_height();
}
inline void KeyPhysicalAttrs::_internal_set_height(int32_t value) {
  
  _impl_.height_ = value;
}
inline void KeyPhysicalAttrs::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.height)
}

// sint32 x = 3;
inline void KeyPhysicalAttrs::clear_x() {
  _impl_.x_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_x() const {
  return _impl_.x_;
}
inline int32_t KeyPhysicalAttrs::x() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.x)
  return _internal_x();
}
inline void KeyPhysicalAttrs::_internal_set_x(int32_t value) {
  
  _impl_.x_ = value;
}
inline void KeyPhysicalAttrs::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.x)
}

// sint32 y = 4;
inline void KeyPhysicalAttrs::clear_y() {
  _impl_.y_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_y() const {
  return _impl_.y_;
}
inline int32_t KeyPhysicalAttrs::y() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.y)
  return _internal_y();
}
inline void KeyPhysicalAttrs::_internal_set_y(int32_t value) {
  
  _impl_.y_ = value;
}
inline void KeyPhysicalAttrs::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.y)
}

// sint32 r = 5;
inline void KeyPhysicalAttrs::clear_r() {
  _impl_.r_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_r() const {
  return _impl_.r_;
}
inline int32_t KeyPhysicalAttrs::r() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.r)
  return _internal_r();
}
inline void KeyPhysicalAttrs::_internal_set_r(int32_t value) {
  
  _impl_.r_ = value;
}
inline void KeyPhysicalAttrs::set_r(int32_t value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.r)
}

// sint32 rx = 6;
inline void KeyPhysicalAttrs::clear_rx() {
  _impl_.rx_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_rx() const {
  return _impl_.rx_;
}
inline int32_t KeyPhysicalAttrs::rx() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.rx)
  return _internal_rx();
}
inline void KeyPhysicalAttrs::_internal_set_rx(int32_t value) {
  
  _impl_.rx_ = value;
}
inline void KeyPhysicalAttrs::set_rx(int32_t value) {
  _internal_set_rx(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.rx)
}

// sint32 ry = 7;
inline void KeyPhysicalAttrs::clear_ry() {
  _impl_.ry_ = 0;
}
inline int32_t KeyPhysicalAttrs::_internal_ry() const {
  return _impl_.ry_;
}
inline int32_t KeyPhysicalAttrs::ry() const {
  // @@protoc_insertion_point(field_get:zmk.keymap.KeyPhysicalAttrs.ry)
  return _internal_ry();
}
inline void KeyPhysicalAttrs::_internal_set_ry(int32_t value) {
  
  _impl_.ry_ = value;
}
inline void KeyPhysicalAttrs::set_ry(int32_t value) {
  _internal_set_ry(value);
  // @@protoc_insertion_point(field_set:zmk.keymap.KeyPhysicalAttrs.ry)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace keymap
}  // namespace zmk

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::zmk::keymap::SaveChangesErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::SaveChangesErrorCode>() {
  return ::zmk::keymap::SaveChangesErrorCode_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::SetLayerBindingResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::SetLayerBindingResponse>() {
  return ::zmk::keymap::SetLayerBindingResponse_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::MoveLayerErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::MoveLayerErrorCode>() {
  return ::zmk::keymap::MoveLayerErrorCode_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::AddLayerErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::AddLayerErrorCode>() {
  return ::zmk::keymap::AddLayerErrorCode_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::RemoveLayerErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::RemoveLayerErrorCode>() {
  return ::zmk::keymap::RemoveLayerErrorCode_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::RestoreLayerErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::RestoreLayerErrorCode>() {
  return ::zmk::keymap::RestoreLayerErrorCode_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::SetLayerPropsResponse> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::SetLayerPropsResponse>() {
  return ::zmk::keymap::SetLayerPropsResponse_descriptor();
}
template <> struct is_proto_enum< ::zmk::keymap::SetActivePhysicalLayoutErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::zmk::keymap::SetActivePhysicalLayoutErrorCode>() {
  return ::zmk::keymap::SetActivePhysicalLayoutErrorCode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_keymap_2eproto
